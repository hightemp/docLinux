# Bash-скрипты

[Bash-скрипты: начало](#user-content-bash-скрипты-начало)  
[Bash-скрипты, часть 2: циклы](#user-content-bash-скрипты-часть-2-циклы)  
[Bash-скрипты, часть 3: параметры и ключи командной строки](#user-content-bash-скрипты-часть-3-параметры-и-ключи-командной-строки)  
[Bash-скрипты, часть 4: ввод и вывод](#user-content-bash-скрипты-часть-4-ввод-и-вывод)  
[Bash-скрипты, часть 5: сигналы, фоновые задачи, управление сценариями](#user-content-bash-скрипты-часть-5-сигналы-фоновые-задачи-управление-сценариями)  
[Bash-скрипты, часть 6: функции и разработка библиотек](#user-content-bash-скрипты-часть-6-функции-и-разработка-библиотек)  
[Bash-скрипты, часть 7: sed и обработка текстов](#user-content-bash-скрипты-часть-7-sed-и-обработка-текстов)  
[Bash-скрипты, часть 8: язык обработки данных awk](#user-content-bash-скрипты-часть-8-язык-обработки-данных-awk)  
[Bash-скрипты, часть 9: регулярные выражения](#user-content-bash-скрипты-часть-9-регулярные-выражения)  
[Bash-скрипты, часть 10: практические примеры](#user-content-bash-скрипты-часть-10-практические-примеры)  
[Bash-скрипты, часть 11: expect и автоматизация интерактивных утилит](#user-content-bash-скрипты-часть-11-expect-и-автоматизация-интерактивных-утилит)

# Bash-скрипты: начало

## Как устроены bash-скрипты

  
Создайте пустой файл с использованием команды `touch`. В его первой строке нужно указать, какую именно оболочку мы собираемся использовать. Нас интересует `bash`, поэтому первая строка файла будет такой:  
  

```bash
#!/bin/bash
```

  
В других строках этого файла символ решётки используется для обозначения комментариев, которые оболочка не обрабатывает. Однако, первая строка — это особый случай, здесь решётка, за которой следует восклицательный знак (эту последовательность называют [шебанг](https://ru.wikipedia.org/wiki/%D0%A8%D0%B5%D0%B1%D0%B0%D0%BD%D0%B3_(Unix))) и путь к`bash`, указывают системе на то, что сценарий создан именно для `bash`.  
  
Команды оболочки отделяются знаком перевода строки, комментарии выделяют знаком решётки. Вот как это выглядит:  
  

```bash
#!/bin/bash
# This is a comment
pwd
whoami
```

  
Тут, так же, как и в командной строке, можно записывать команды в одной строке, разделяя точкой с запятой. Однако, если писать команды на разных строках, файл легче читать. В любом случае оболочка их обработает.  
  

## Установка разрешений для файла сценария

  
Сохраните файл, дав ему имя`myscript`, и работа по созданию bash-скрипта почти закончена. Сейчас осталось лишь сделать этот файл исполняемым, иначе, попытавшись его запустить, вы столкнётесь с ошибкой`Permission denied`.  
  

![](/images/29f7433ec002900e7518396a814fe351.png)

  
_Попытка запуска файла сценария с неправильно настроенными разрешениями_  
  
Сделаем файл исполняемым:  
  

```
chmod +x ./myscript
```

  
Теперь попытаемся его выполнить:  
  

```
./myscript
```

  
После настройки разрешений всё работает как надо.  
  

![](/images/736e671a5ff9a96e10bbb3c7e8ae537a.png)

  
_Успешный запуск bash-скрипта_  
  

## Вывод сообщений

  
Для вывода текста в консоль Linux применяется команда`echo`. Воспользуемся знанием этого факта и отредактируем наш скрипт, добавив пояснения к данным, которые выводят уже имеющиеся в нём команды:  
  

```bash
#!/bin/bash
# our comment is here
echo "The current directory is:"
pwd
echo "The user logged in is:"
whoami
```

  
Вот что получится после запуска обновлённого скрипта.  
  

![](/images/4d0173e3ddcad01d0790b6b98dd91315.png)

  
_Вывод сообщений из скрипта_  
  
Теперь мы можем выводить поясняющие надписи, используя команду`echo`. Если вы не знаете, как отредактировать файл, пользуясь средствами Linux, или раньше не встречались с командой`echo`, взгляните на[этот](https://likegeeks.com/basic-linux-commands-part2/)материал.  
  

## Использование переменных

  
Переменные позволяют хранить в файле сценария информацию, например — результаты работы команд для использования их другими командами.  
  
Нет ничего плохого в исполнении отдельных команд без хранения результатов их работы, но возможности такого подхода весьма ограничены.  
  
Существуют два типа переменных, которые можно использовать в bash-скриптах:  
  

*   Переменные среды
*   Пользовательские переменные

  

## Переменные среды

  
Иногда в командах оболочки нужно работать с некими системными данными. Вот, например, как вывести домашнюю директорию текущего пользователя:  
  

```bash
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
```

  
Обратите внимание на то, что мы можем использовать системную переменную`$HOME`в двойных кавычках, это не помешает системе её распознать. Вот что получится, если выполнить вышеприведённый сценарий.  
  

![](/images/da06b64a489f6a8e16a3ca345f270f82.png)

  
_Использование переменной среды в сценарии_  
  
А что если надо вывести на экран значок доллара? Попробуем так:  
  

```bash
echo "I have $1 in my pocket"
```

  
Система обнаружит знак доллара в строке, ограниченной кавычками, и решит, что мы сослались на переменную. Скрипт попытается вывести на экран значение неопределённой переменной`$1`. Это не то, что нам нужно. Что делать?  
  
В подобной ситуации поможет использование управляющего символа, обратной косой черты, перед знаком доллара:  
  

```bash
echo "I have \$1 in my pocket"
```

  
Теперь сценарий выведет именно то, что ожидается.  
  

![](/images/771a8a7102c7a25f1ecd1e739a00de6e.png)

  
_Использование управляющей последовательности для вывода знака доллара_  
  

## Пользовательские переменные

  
В дополнение к переменным среды, bash-скрипты позволяют задавать и использовать в сценарии собственные переменные. Подобные переменные хранят значение до тех пор, пока не завершится выполнение сценария.  
  
Как и в случае с системными переменными, к пользовательским переменным можно обращаться, используя знак доллара:  
TNW-CUS-FMP — промо-код на 10% скидку на наши услуги, доступен для активации в течение 7 дней  

```bash
#!/bin/bash
# testing variables
grade=5
person="Adam"
echo "$person is a good boy, he is in grade $grade"
```

  
Вот что получится после запуска такого сценария.  
  

![](/images/3a736714c8f9db68ef8fce923b3cc5e5.png)

  
_Пользовательские переменные в сценарии_  
  

## Подстановка команд

  
Одна из самых полезных возможностей bash-скриптов — это возможность извлекать информацию из вывода команд и назначать её переменным, что позволяет использовать эту информацию где угодно в файле сценария.  
  
Сделать это можно двумя способами.  
  

*   С помощью значка обратного апострофа «\`»
*   С помощью конструкции`$()`

  
Используя первый подход, проследите за тем, чтобы вместо обратного апострофа не ввести одиночную кавычку. Команду нужно заключить в два таких значка:  
  

```bash
mydir=`pwd`
```

  
При втором подходе то же самое записывают так:  
  

```bash
mydir=$(pwd)
```

  
А скрипт, в итоге, может выглядеть так:  
  

```bash
#!/bin/bash
mydir=$(pwd)
echo $mydir
```

  
В ходе его работы вывод команды`pwd`будет сохранён в переменной`mydir`, содержимое которой, с помощью команды`echo`, попадёт в консоль.  
  

![](/images/acc127fa3826130cb82854c74d6fd5f4.png)

  
_Скрипт, сохраняющий результаты работы команды в переменной_  
  

## Математические операции

  
Для выполнения математических операций в файле скрипта можно использовать конструкцию вида`$((a+b))`:  
  

```bash
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1
var2=$(( $var1 * 2 ))
echo $var2
```

  

![](/images/a3c9b03dcc99367ba2e80f3695282154.png)

  
_Математические операции в сценарии_  
  

## Управляющая конструкция if-then

  
В некоторых сценариях требуется управлять потоком исполнения команд. Например, если некое значение больше пяти, нужно выполнить одно действие, в противном случае — другое. Подобное применимо в очень многих ситуациях, и здесь нам поможет управляющая конструкция`if-then`. В наиболее простом виде она выглядит так:  
  

```bash
if команда
then
команды
fi
```

  
А вот рабочий пример:  
  

```bash
#!/bin/bash
if pwd
then
echo "It works"
fi
```

  
В данном случае, если выполнение команды`pwd`завершится успешно, в консоль будет выведен текст «it works».  
  
Воспользуемся имеющимися у нас знаниями и напишем более сложный сценарий. Скажем, надо найти некоего пользователя в`/etc/passwd`, и если найти его удалось, сообщить о том, что он существует.  
  

```bash
#!/bin/bash
user=likegeeks
if grep $user /etc/passwd
then
echo "The user $user Exists"
fi
```

  
Вот что получается после запуска этого скрипта.  
  

![](/images/395e1765efb8d9b3fe1726240357dcc4.png)

  
_Поиск пользователя_  
  
Здесь мы воспользовались командой`grep`для поиска пользователя в файле`/etc/passwd`. Если команда`grep`вам незнакома, её описание можно найти[здесь](https://likegeeks.com/main-linux-commands-easy-guide/).  
  
В этом примере, если пользователь найден, скрипт выведет соответствующее сообщение. А если найти пользователя не удалось? В данном случае скрипт просто завершит выполнение, ничего нам не сообщив. Хотелось бы, чтобы он сказал нам и об этом, поэтому усовершенствуем код.  
  

## Управляющая конструкция if-then-else

  
Для того, чтобы программа смогла сообщить и о результатах успешного поиска, и о неудаче, воспользуемся конструкцией`if-then-else`. Вот как она устроена:  
  

```bash
if команда
then
команды
else
команды
fi
```

  
Если первая команда возвратит ноль, что означает её успешное выполнение, условие окажется истинным и выполнение не пойдёт по ветке`else`. В противном случае, если будет возвращено что-то, отличающееся от нуля, что будет означать неудачу, или ложный результат, будут выполнены команды, расположенные после`else`.  
  
Напишем такой скрипт:  
  

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
else
echo "The user $user doesn’t exist"
fi
```

  
Его исполнение пошло по ветке`else`.  
  

![](/images/9dbc75b3dba2778a9aa9ff6b77677328.png)

  
_Запуск скрипта с конструкцией if-then-else_  
  
Ну что же, продолжаем двигаться дальше и зададимся вопросом о более сложных условиях. Что если надо проверить не одно условие, а несколько? Например, если нужный пользователь найден, надо вывести одно сообщение, если выполняется ещё какое-то условие — ещё одно сообщение, и так далее. В подобной ситуации нам помогут вложенные условия. Выглядит это так:  
  

```bash
if команда1
then
команды
elif команда2
then
команды
fi
```

  
Если первая команда вернёт ноль, что говорит о её успешном выполнении, выполнятся команды в первом блоке`then`, иначе, если первое условие окажется ложным, и если вторая команда вернёт ноль, выполнится второй блок кода.  
  

```bash
#!/bin/bash
user=anotherUser
if grep $user /etc/passwd
then
echo "The user $user Exists"
elif ls /home
then
echo "The user doesn’t exist but anyway there is a directory under /home"
fi
```

  
В подобном скрипте можно, например, создавать нового пользователя с помощью команды`useradd`, если поиск не дал результатов, или делать ещё что-нибудь полезное.  
  

## Сравнение чисел

  
В скриптах можно сравнивать числовые значения. Ниже приведён список соответствующих команд.  
  

> `n1 -eq n2`Возвращает истинное значение, если`n1`равно`n2`.  
> `n1 -ge n2`Возвращает истинное значение, если`n1`больше или равно`n2`.  
> `n1 -gt n2`Возвращает истинное значение, если`n1`больше`n2`.  
> `n1 -le n2`Возвращает истинное значение, если`n1`меньше или равно`n2`.  
> `n1 -lt n2`Возвращает истинное значение, если n1 меньше`n2`.  
> `n1 -ne n2`Возвращает истинное значение, если`n1`не равно`n2`.

  
В качестве примера опробуем один из операторов сравнения. Обратите внимание на то, что выражение заключено в квадратные скобки.  
  

```bash
#!/bin/bash
val1=6
if [ $val1 -gt 5 ]
then
echo "The test value $val1 is greater than 5"
else
echo "The test value $val1 is not greater than 5"
fi
```

  
Вот что выведет эта команда.  
  

![](/images/bd850959bf5385f0e3a3fa2173fb39a8.png)

  
_Сравнение чисел в скриптах_  
  
Значение переменной`val1`больше чем 5, в итоге выполняется ветвь`then`оператора сравнения и в консоль выводится соответствующее сообщение.  
  

## Сравнение строк

  
В сценариях можно сравнивать и строковые значения. Операторы сравнения выглядят довольно просто, однако у операций сравнения строк есть определённые особенности, которых мы коснёмся ниже. Вот список операторов.  
  

> `str1 = str2`Проверяет строки на равенство, возвращает истину, если строки идентичны.  
> s`tr1 != str2`Возвращает истину, если строки не идентичны.  
> `str1 < str2`Возвращает истину, если`str1`меньше, чем`str2`.  
> `str1 > str2`Возвращает истину, если`str1`больше, чем`str2`.  
> `-n str1`Возвращает истину, если длина`str1`больше нуля.  
> `-z str1`Возвращает истину, если длина`str1`равна нулю.

  
Вот пример сравнения строк в сценарии:  
  

```bash
#!/bin/bash
user ="likegeeks"
if [$user = $USER]
then
echo "The user $user  is the current logged in user"
fi
```

  
В результате выполнения скрипта получим следующее.  
  

![](/images/55c79a3f28c78c48bcb0560236e09f9c.png)

  
_Сравнение строк в скриптах_  
  
Вот одна особенность сравнения строк, о которой стоит упомянуть. А именно, операторы «>» и «<» необходимо экранировать с помощью обратной косой черты, иначе скрипт будет работать неправильно, хотя сообщений об ошибках и не появится. Скрипт интерпретирует знак «>» как команду перенаправления вывода.  
  
Вот как работа с этими операторами выглядит в коде:  
  

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Вот результаты работы скрипта.  
  

![](/images/4cf2c4079e42367f9e061cfee547e6b0.png)

  
_Сравнение строк, выведенное предупреждение_  
  
Обратите внимание на то, что скрипт, хотя и выполняется, выдаёт предупреждение:  
  

```
./myscript: line 5: [: too many arguments
```

  
Для того, чтобы избавиться от этого предупреждения, заключим`$val2`в двойные кавычки:  
  

```bash
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Теперь всё работает как надо.  
  

![](/images/8e9cd9a8f743b7789841173671cfe26c.png)

  
_Сравнение строк_  
  
Ещё одна особенность операторов «>» и «<» заключается в том, как они работают с символами в верхнем и нижнем регистрах. Для того, чтобы понять эту особенность, подготовим текстовый файл с таким содержимым:  
  

```
Likegeeks
likegeeks
```

  
Сохраним его, дав имя`myfile`, после чего выполним в терминале такую команду:  
  

```
sort myfile
```

  
Она отсортирует строки из файла так:  
  

```
likegeeks
Likegeeks
```

  
Команда`sort`, по умолчанию, сортирует строки по возрастанию, то есть строчная буква в нашем примере меньше прописной. Теперь подготовим скрипт, который будет сравнивать те же строки:  
  

```bash
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

  
Если его запустить, окажется, что всё наоборот — строчная буква теперь больше прописной.  
  

![](/images/ccac6688ceb2d01f4e906620c8c0244a.png)

  
_Команда sort и сравнение строк в файле сценария_  
  
В командах сравнения прописные буквы меньше строчных. Сравнение строк здесь выполняется путём сравнения ASCII-кодов символов, порядок сортировки, таким образом, зависит от кодов символов.  
  
Команда`sort`, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.  
  

## Проверки файлов

  
Пожалуй, нижеприведённые команды используются в bash-скриптах чаще всего. Они позволяют проверять различные условия, касающиеся файлов. Вот список этих команд.  
  

> `-d file`Проверяет, существует ли файл, и является ли он директорией.  
> `-e file`Проверяет, существует ли файл.  
> `-f file`Проверяет, существует ли файл, и является ли он файлом.  
> `-r file`Проверяет, существует ли файл, и доступен ли он для чтения.  
> `-s file П`роверяет, существует ли файл, и не является ли он пустым.  
> `-w file`Проверяет, существует ли файл, и доступен ли он для записи.  
> `-x file`Проверяет, существует ли файл, и является ли он исполняемым.  
> `file1 -nt file2`Проверяет, новее ли`file1`, чем`file2`.  
> `file1 -ot file2`Проверяет, старше ли`file1`, чем`file2`.  
> `-O file`Проверяет, существует ли файл, и является ли его владельцем текущий пользователь.  
> `-G file`Проверяет, существует ли файл, и соответствует ли его идентификатор группы идентификатору группы текущего пользователя.

  
Эти команды, как впрочем, и многие другие рассмотренные сегодня, несложно запомнить. Их имена, являясь сокращениями от различных слов, прямо указывают на выполняемые ими проверки.  
  
Опробуем одну из команд на практике:  
  

```bash
#!/bin/bash
mydir=/home/likegeeks
if [ -d $mydir ]
then
echo "The $mydir directory exists"
cd $ mydir
ls
else
echo "The $mydir directory does not exist"
fi
```

  
Этот скрипт, для существующей директории, выведет её содержимое.  
  

![](/images/ab22e20e730bb0c56cef8da5c8d31dba.png)

  
_Вывод содержимого директории_  
  
Полагаем, с остальными командами вы сможете поэкспериментировать самостоятельно, все они применяются по тому же принципу.

# Bash-скрипты, часть 2: циклы

## Циклы for

  
Оболочка bash поддерживает циклы`for`, которые позволяют организовывать перебор последовательностей значений. Вот какова базовая структура таких циклов:  
  

```bash
for var in list
do
команды
done
```

  
В каждой итерации цикла в переменную`var`будет записываться следующее значение из списка`list`. В первом проходе цикла, таким образом, будет задействовано первое значение из списка. Во втором — второе, и так далее — до тех пор, пока цикл не дойдёт до последнего элемента.  
  

## Перебор простых значений

  
Пожалуй, самый простой пример цикла`for`в bash-скриптах — это перебор списка простых значений:  
  

```bash
#!/bin/bash
for var in first second third fourth fifth
do
echo The  $var item
done
```

  
Ниже показаны результаты работы этого скрипта. Хорошо видно, что в переменную`$var`последовательно попадают элементы из списка. Происходит так до тех пор, пока цикл не дойдёт до последнего из них.  
  
![](/images/029f5b70be710c0aab128d612e7ca4bc.png)  
_Простой цикл for_  
  
Обратите внимание на то, что переменная`$var`сохраняет значение при выходе из цикла, её содержимое можно менять, в целом, работать с ней можно как с любой другой переменной.  
  

## Перебор сложных значений

  
В списке, использованном при инициализации цикла`for`, могут содержаться не только простые строки, состоящие из одного слова, но и целые фразы, в которые входят несколько слов и знаков препинания. Например, всё это может выглядеть так:  
  

```bash
#!/bin/bash
for var in first "the second" "the third" "I’ll do it"
do
echo "This is: $var"
done
```

  
Вот что получится после того, как этот цикл пройдётся по списку. Как видите, результат вполне ожидаем.  
  
![](/images/2e5e3f0e856ee457a7c821f1fa3126b8.png)  
_Перебор сложных значений_  
TNW-CUS-FMP — промо-код на 10% скидку на наши услуги, доступен для активации в течение 7 дней"  

## Инициализация цикла списком, полученным из результатов работы команды

  
Ещё один способ инициализации цикла`for`заключается в передаче ему списка, который является результатом работы некоей команды. Тут используется подстановка команд для их исполнения и получения результатов их работы.  
  

```bash
#!/bin/bash
file="myfile"
for var in $(cat $file)
do
echo " $var"
done
```

  
В этом примере задействована команда`cat`, которая читает содержимое файла. Полученный список значений передаётся в цикл и выводится на экран. Обратите внимание на то, что в файле, к которому мы обращаемся, содержится список слов, разделённых знаками перевода строки, пробелы при этом не используются.  
  
![](/images/84276530b0d56f7d038aaa0a1f80906f.png)  
_Цикл, который перебирает содержимое файла_  
  
Тут надо учесть, что подобный подход, если ожидается построчная обработка данных, не сработает для файла более сложной структуры, в строках которого может содержаться по несколько слов, разделённых пробелами. Цикл будет обрабатывать отдельные слова, а не строки.  
  
Что, если это совсем не то, что нужно?  
  

## Разделители полей

  
Причина вышеописанной особенности заключается в специальной переменной окружения, которая называется`IFS`(Internal Field Separator) и позволяет указывать разделители полей. По умолчанию оболочка bash считает разделителями полей следующие символы:  
  

*   Пробел
*   Знак табуляции
*   Знак перевода строки

  
Если bash встречает в данных любой из этих символов, он считает, что перед ним — следующее самостоятельное значение списка.  
  
Для того, чтобы решить проблему, можно временно изменить переменную среды`IFS`. Вот как это сделать в bash-скрипте, если исходить из предположения, что в качестве разделителя полей нужен только перевод строки:  
  

```bash
IFS=$'\n'
```

  
После добавления этой команды в bash-скрипт, он будет работать как надо, игнорируя пробелы и знаки табуляции, считая разделителями полей лишь символы перевода строки.  
  

```bash
#!/bin/bash
file="/etc/passwd"
IFS=$'\n'
for var in $(cat $file)
do
echo " $var"
done
```

  
Если этот скрипт запустить, он выведет он именно то, что от него требуется, давая, в каждой итерации цикла, доступ к очередной строке, записанной в файл.  
  
![](/images/6f7574e2270854b6200d686ab2682676.png)  
_Построчный обход содержимого файла в цикле for_  
  
Разделителями могут быть и другие символы. Например, выше мы выводили на экран содержимое файла`/etc/passwd`. Данные о пользователях в строках разделены с помощью двоеточий. Если в цикле нужно обрабатывать подобные строки,`IFS`можно настроить так:  
  

```bash
IFS=:
```

  

## Обход файлов, содержащихся в директории

  
Один из самых распространённых вариантов использования циклов`for`в bash-скриптах заключается в обходе файлов, находящихся в некоей директории, и в обработке этих файлов.  
  
Например, вот как можно вывести список файлов и папок:  
  

```bash
#!/bin/bash
for file in /home/likegeeks/*
do
if [ -d "$file" ]
then
echo "$file is a directory"
elif [ -f "$file" ]
then
echo "$file is a file"
fi
done
```

  
Если вы разобрались с[предыдущим материалом](https://habrahabr.ru/company/ruvds/blog/325522/)из этой серии статей, вам должно быть понятно устройство конструкции`if-then`, а так же то, как отличить файл от папки. Если вам сложно понять вышеприведённый код, перечитайте этот материал.  
  
Вот что выведет скрипт.  
  
![](/images/ec6291ec1b9fbd8e262035bd0bea80c0.png)  
_Вывод содержимого папки_  
  
Обратите внимание на то, как мы инициализируем цикл, а именно — на подстановочный знак «\*» в конце адреса папки. Этот символ можно воспринимать как шаблон, означающий: «все файлы с любыми именами». он позволяет организовать автоматическую подстановку имён файлов, которые соответствуют шаблону.  
  
При проверке условия в операторе`if`, мы заключаем имя переменной в кавычки. Сделано это потому что имя файла или папки может содержать пробелы.  
  

## Циклы for в стиле C

  
Если вы знакомы с языком программирования C, синтаксис описания bash-циклов`for`может показаться вам странным, так как привыкли вы, очевидно, к такому описанию циклов:  
  

```bash
for (i = 0; i < 10; i++)
{
printf("number is %d\n", i);
}
```

  
В bash-скриптах можно использовать циклы`for`, описание которых выглядит очень похожим на циклы в стиле C, правда, без некоторых отличий тут не обошлось. Схема цикла при подобном подходе выглядит так:  
  

```bash
for (( начальное значение переменной ; условие окончания цикла; изменение переменной ))
```

  
На bash это можно написать так:  
  

```bash
for (( a = 1; a < 10; a++ ))
```

  
А вот рабочий пример:  
  

```bash
#!/bin/bash
for (( i=1; i <= 10; i++ ))
do
echo "number is $i"
done
```

  
Этот код выведет список чисел от 1 до 10.  
  
![](/images/8-guFEwLQA0SipmlUF_kzBsryGEkadB6YpmmNL62_-2Dl-tUywrP1mEFU_Fy8jhU9jyid3WF7RAHkBv-rYJUmDVp7TFSKx3bYQZ6qFwtP1Bz4lIx5dbFRB9W1zI7ABbeus3QV--1P3X8jubvOw)  
_Работа цикла в стиле C_  
  

## Цикл while

  
Конструкция`for —`не единственный способ организации циклов в bash-скриптах. Здесь можно пользоваться и циклами`while`. В таком цикле можно задать команду проверки некоего условия и выполнять тело цикла до тех пор, пока проверяемое условие возвращает ноль, или сигнал успешного завершения некоей операции. Когда условие цикла вернёт ненулевое значение, что означает ошибку, цикл остановится.  
  
Вот схема организации циклов`while  
while команда проверки условия  
do  
другие команды  
done`  
  
Взглянем на пример скрипта с таким циклом:  
  

```bash
#!/bin/bash
var1=5
while [ $var1 -gt 0 ]
do
echo $var1
var1=$[ $var1 - 1 ]
done
```

  
На входе в цикл проверяется, больше ли нуля переменная`$var1`. Если это так, выполняется тело цикла, в котором из значения переменной вычитается единица. Так происходит в каждой итерации, при этом мы выводим в консоль значение переменной до его модификации. Как только`$var1`примет значение 0, цикл прекращается.  
  
![](/images/K5622UUyXnl1vSr1fN3I6OHVs13jA8Huyge-OdZ7y9lJ0HRGEMlcpFb__ouQjveVOtyQzz0xHUh_gyncw28oBk1oI7PGJUVUAG0tagG7BqX7ir7flGkO7qHkV5i8TKgpn-y_LXoYAccT2fKYnw)  
_Результат работы цикла while_  
  
Если не модифицировать переменную`$var1`, это приведёт к попаданию скрипта в бесконечный цикл.  
  

## Вложенные циклы

  
В теле цикла можно использовать любые команды, в том числе — запускать другие циклы. Такие конструкции называют вложенными циклами:  
  

```bash
#!/bin/bash
for (( a = 1; a <= 3; a++ ))
do
echo "Start $a:"
for (( b = 1; b <= 3; b++ ))
do
echo " Inner loop: $b"
done
done
```

  
Ниже показано то, что выведет этот скрипт. Как видно, сначала выполняется первая итерация внешнего цикла, потом — три итерации внутреннего, после его завершения снова в дело вступает внешний цикл, потом опять — внутренний.  
  
![](/images/K7DsBP72Y0CQuHSL3X-HmcYhfgsQtsEXwpEU8Xr1dQFsKRHZQ7LqyuhfUhdReJGxW2gbAoGXBSB1VeM7r5cmH7HG9VWkhaEy7UzZ3YEHIO_E3ND_w5mZtD4Bd-i0Ml3hSSWKHRurziyR_7v_Fg)  
_Вложенные циклы_  
  

## Обработка содержимого файла

  
Чаще всего вложенные циклы используют для обработки файлов. Так, внешний цикл занимается перебором строк файла, а внутренний уже работает с каждой строкой. Вот, например, как выглядит обработка файла`/etc/passwd`:  
  

```bash
#!/bin/bash
IFS=$'\n'
for entry in $(cat /etc/passwd)
do
echo "Values in $entry –"
IFS=:
for value in $entry
do
echo " $value"
done
done
```

  
В этом скрипте два цикла. Первый проходится по строкам, используя в качестве разделителя знак перевода строки. Внутренний занят разбором строк, поля которых разделены двоеточиями.  
  
![](/images/-UGOy-2GpL_7qZWtQBuWR8oQrH0aXWpQouE0wIZyuuadWJRchjUC6YWZqfNLdb3u7ECzf_N3pbz2rE3VR_9ptwGQKruBLARv1c_ZlnGvi0uNICw2le_aIRZxP88us9iWdLxxfEr81Glj52oQAw)  
_Обработка данных файла_  
  
Такой подход можно использовать при обработке файлов формата CSV, или любых подобных файлов, записывая, по мере надобности, в переменную окружения`IFS`символ-разделитель.  
  

## Управление циклами

  
Возможно, после входа в цикл, нужно будет остановить его при достижении переменной цикла определённого значения, которое не соответствует изначально заданному условию окончания цикла. Надо ли будет в такой ситуации дожидаться нормального завершения цикла? Нет конечно, и в подобных случаях пригодятся следующие две команды:  
  

*   `break`
*   `continue`

  

## Команда break

  
Эта команда позволяет прервать выполнение цикла. Её можно использовать и для циклов`for`, и для циклов`while`:  
  

```bash
#!/bin/bash
for var1 in 1 2 3 4 5 6 7 8 9 10
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Number: $var1"
done
```

  
Такой цикл, в обычных условиях, пройдётся по всему списку значений из списка. Однако, в нашем случае, его выполнение будет прервано, когда переменная`$var1`будет равна 5.  
  
![](/images/jg4xtN1I0tln8w8dm_b5XtbHIbd5yI2EAg6ziWENCpt-GAiU4prXiarHbnzWMzK-wajj3aRlwSKXi2uIjdAvaKGos4ReXP46AytgRFap0-PiD23ikSAX4ZvD1mRpYxWkbUzTf1P5MS8gQiXIkw)  
_Досрочный выход из цикла for_  
  
Вот — то же самое, но уже для цикла`while`:  
  

```bash
#!/bin/bash
var1=1
while [ $var1 -lt 10 ]
do
if [ $var1 -eq 5 ]
then
break
fi
echo "Iteration: $var1"
var1=$(( $var1 + 1 ))
done
```

  
Команда`break`, исполненная, когда значение`$var1`станет равно 5, прерывает цикл. В консоль выведется то же самое, что и в предыдущем примере.  
  

## Команда continue

  
Когда в теле цикла встречается эта команда, текущая итерация завершается досрочно и начинается следующая, при этом выхода из цикла не происходит. Посмотрим на команду`continue`в цикле`for`:  
  

```bash
#!/bin/bash
for (( var1 = 1; var1 < 15; var1++ ))
do
if [ $var1 -gt 5 ] && [ $var1 -lt 10 ]
then
continue
fi
echo "Iteration number: $var1"
done
```

  
Когда условие внутри цикла выполняется, то есть, когда`$var1`больше 5 и меньше 10, оболочка исполняет команду`continue`. Это приводит к пропуску оставшихся в теле цикла команд и переходу к следующей итерации.  
  
![](/images/DDo9QcLuEBjIHQkg9HyusIc3A1FzUWxFKojTylwEcRdMLBvW5xv8Wofn1zbz4Usogq2l2JM3qg8f4rv9odlF6ozzoMrPD7zBWSRWp32--pok6xm0DowP7GczN2QjhTnUm9rk2fDeIHnAuhcxdA)  
_Команда continue в цикле for_  
  

## Обработка вывода, выполняемого в цикле

  
Данные, выводимые в цикле, можно обработать, либо перенаправив вывод, либо передав их в конвейер. Делается это с помощью добавления команд обработки вывода после инструкции`done`.  
  
Например, вместо того, чтобы показывать на экране то, что выводится в цикле, можно записать всё это в файл или передать ещё куда-нибудь:  
  

```bash
#!/bin/bash
for (( a = 1; a < 10; a++ ))
do
echo "Number is $a"
done > myfile.txt
echo "finished."
```

  
Оболочка создаст файл`myfile.txt`и перенаправит в этот файл вывод конструкции`for`. Откроем файл и удостоверимся в том, что он содержит именно то, что ожидается.  
  
![](/images/AsNK_vEGXArctfRWFAThFNvAOW5HbLQqksos7Ul6_WJke0QLYj1DA0Hs65hPL0JbXhbdDgxz5ZDkLfTVNhNqRrB8CUyIb-T1IzwRGnzT_x_FVah19HRAMMicXLqrhn0NZieQBvIDVIrsOrqMEQ)  
_Перенаправление вывода цикла в файл_  
  

## Пример: поиск исполняемых файлов

  
Давайте воспользуемся тем, что мы уже разобрали, и напишем что-нибудь полезное. Например, если надо выяснить, какие именно исполняемые файлы доступны в системе, можно просканировать все папки, записанные в переменную окружения`PATH`. Весь арсенал средств, который для этого нужен, у нас уже есть, надо лишь собрать всё это воедино:  
  

```bash
#!/bin/bash
IFS=:
for folder in $PATH
do
echo "$folder:"
for file in $folder/*
do
if [ -x $file ]
then
echo " $file"
fi
done
done
```

  
Такой вот скрипт, небольшой и несложный, позволил получить список исполняемых файлов, хранящихся в папках из`PATH`.  
  
![](/images/FZHEGCXR9tyDXnMNVHV9voO5YxjW3Kb3tasZNXiTztDqdd1eaNjGm8EEFUM3U2e3_VC0GSY0O_TuTMZC4jKuR9dyyGzLtl0vHfZcpc2ARbAQN_98gAXM_bIucW-h7RD7y2YcKEvFokgJH0ZwUw)  
_Поиск исполняемых файлов в папках из переменной PATH_

# Bash-скрипты, часть 3: параметры и ключи командной строки

## Чтение параметров командной строки

  
Оболочка bash назначает специальным переменным, называемым позиционными параметрами, введённые при вызове скрипта параметры командной строки:  
  

*   `$0` — имя скрипта.  
    
*   `$1` — первый параметр.  
    
*   `$2` — второй параметр — и так далее, вплоть до переменной`$9`, в которую попадает девятый параметр.  
    

  
Вот как можно использовать параметры командной строки в скрипте с помощью этих переменных:  
  

```bash
#!/bin/bash
echo $0
echo $1
echo $2
echo $3
```

  
Запустим сценарий с параметрами:  
  

```
./myscript 5 10 15
```

  
Вот что он выведет в консоль.  
  

![](/images/fb5f9fb80361a4083e31d7225fa3cdbf.png)

  
_Вывод параметров, с которыми запущен скрипт_  
  
Обратите внимание на то, что параметры командной строки разделяются пробелами.  
  
Взглянем на ещё один пример использования параметров. Тут мы найдём сумму чисел, переданных сценарию:  
  

```bash
#!/bin/bash
total=$[ $1 + $2 ]
echo The first parameter is $1.
echo The second parameter is $2.
echo The sum is $total.
```

  
Запустим скрипт и проверим результат вычислений.  
  

![](/images/646db142c4fe6ebfc41f66b2a65534e6.png)

  
_Сценарий, который находит сумму переданных ему чисел_  
  
Параметры командной строки не обязательно должны быть числами. Сценариям можно передавать и строки. Например, вот скрипт, работающий со строкой:  
  

```bash
#!/bin/bash
echo Hello $1, how do you do
```

  
Запустим его:  
  

```
./myscript Adam
```

  
Он выведет то, что мы от него ожидаем.  
  

![](/images/f450d1b0337e0533990d1a25f2890e43.png)

  
_Сценарий, работающий со строковым параметром_  
  
Что если параметр содержит пробелы, а нам надо обрабатывать его как самостоятельный фрагмент данных? Полагаем, если вы освоили предыдущие части этого руководства, ответ вы уже знаете. Заключается он в использовании кавычек.  
  
Если скрипту надо больше девяти параметров, при обращении к ним номер в имени переменной надо заключать в фигурные скобки, например так:  
  

```bash
${10}
```

  

## Проверка параметров

  
Если скрипт вызван без параметров, но для нормальной работы кода предполагается их наличие, возникнет ошибка. Поэтому рекомендуется всегда проверять наличие параметров, переданных сценарию при вызове. Например, это можно организовать так:  
  

```bash
#!/bin/bash
if [ -n "$1" ]
then
echo Hello $1.
else
echo "No parameters found. "
fi
```

  
Вызовем скрипт сначала с параметром, а потом без параметров.  
  

![](/images/b8c9ce15f6793d007f1d5460a7a20078.png)

  
_Вызов скрипта, проверяющего наличие параметров командной строки_  
  

## Подсчёт параметров

  
В скрипте можно подсчитать количество переданных ему параметров. Оболочка bash предоставляет для этого специальную переменную. А именно, переменная`$#`содержит количество параметров, переданных сценарию при вызове.  
  
Опробуем её:  
  

```bash
#!/bin/bash
echo There were $# parameters passed.
```

  
Вызовем сценарий.  
  

```
./myscript 1 2 3 4 5
```

  
В результате скрипт сообщит о том, что ему передано 5 параметров.  
  

![](/images/b4919fe68032df326b43cc39a88e718d.png)

  
_Подсчёт количества параметров в скрипте_  
  
Эта переменная даёт необычный способ получения последнего из переданных скрипту параметров, не требующий знания их количества. Вот как это выглядит:  
  

```bash
#!/bin/bash
echo The last parameter was ${!#}
```

  
Вызовем скрипт и посмотрим, что он выведет.  
  

![](/images/e7f7ed0e751be4c5156ae49b7e8ea86d.png)

  
_Обращение к последнему параметру_  
  

## Захват всех параметров командной строки

  
В некоторых случаях нужно захватить все параметры, переданные скрипту. Для этого можно воспользоваться переменными`$*`и`$@`. Обе они содержат все параметры командной строки, что делает возможным доступ к тому, что передано сценарию, без использования позиционных параметров.  
  
Переменная`$*`содержит все параметры, введённые в командной строке, в виде единого «слова».  
  
В переменной`$@`параметры разбиты на отдельные «слова». Эти параметры можно перебирать в циклах.  
  
Рассмотрим разницу между этими переменными на примерах. Сначала взглянем на их содержимое:  
  

```bash
#!/bin/bash
echo "Using the \$* method: $*"
echo "-----------"
echo "Using the \$@ method: $@"
```

  
Вот вывод скрипта.  
  

![](/images/ee1579f3d1c96830d6c2484f6124c89e.png)

  
_Переменные $\* и $@_  
  
Как видно, при выводе обеих переменных получается одно и то же. Теперь попробуем пройтись по содержимому этих переменных в циклах для того, чтобы увидеть разницу между ними:  
  

```bash
#!/bin/bash
count=1
for param in "$*"
do
echo "\$* Parameter #$count = $param"
count=$(( $count + 1 ))
done
count=1
for param in "$@"
do
echo "\$@ Parameter #$count = $param"
count=$(( $count + 1 ))
done
```

  
Взгляните на то, что скрипт вывел в консоль. Разница между переменными вполне очевидна.  
  

![](/images/4bd369c4cecd29ae7b221dcdbf669fbb.png)

  
_Разбор переменных $\* и $@ в цикле_  
  
Переменная`$*`содержит все переданные скрипту параметры как единый фрагмент данных, в то время как в переменной`$@`они представлены самостоятельными значениями. Какой именно переменной воспользоваться — зависит от того, что именно нужно в конкретном сценарии.  
  

## Команда shift

  
Использовать команду`shift`в bash-скриптах следует с осторожностью, так как она, в прямом смысле слова, сдвигает значения позиционных параметров.  
  
Когда вы используете эту команду, она, по умолчанию, сдвигает значения позиционных параметров влево. Например, значение переменной`$3`становится значением переменной`$2`, значение`$2`переходит в`$1`, а то, что было до этого в`$1,`теряется. Обратите внимание на то, что при этом значение переменной`$0`, содержащей имя скрипта, не меняется.  
  
Воспользовавшись командой`shift`, рассмотрим ещё один способ перебора переданных скрипту параметров:  
  

```bash
#!/bin/bash
count=1
while [ -n "$1" ]
do
echo "Parameter #$count = $1"
count=$(( $count + 1 ))
shift
done
```

  
Скрипт задействует цикл`while`, проверяя длину значения первого параметра. Когда длина станет равна нулю, происходит выход из цикла. После проверки первого параметра и вывода его на экран, вызывается команда`shift`, которая сдвигает значения параметров на одну позицию.  
  

![](/images/db12d91f92f7e8bc7d62a30471638ed3.png)

  
_Использование команды shift для перебора параметров_  
  
Используя команду`shift`, помните о том, что при каждом её вызове значение переменной`$1`безвозвратно теряется.  
  

## Ключи командной строки

  
Ключи командной строки обычно выглядят как буквы, перед которыми ставится тире. Они служат для управления сценариями. Рассмотрим такой пример:  
  

```bash
#!/bin/bash
echo
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option" ;;
-c) echo "Found the -c option" ;;
*) echo "$1 is not an option" ;;
esac
shift
done
```

  
Запустим скрипт:  
  

```
$ ./myscript –a –b –c –d
```

  
И проанализируем то, что он выведет в терминал.  
  

![](/images/2efa185daf65a2171852f56b40c182fb.png)

  
_Обработка ключей в скрипте_  
  
В этом коде использована конструкция`case`, которая сверяет переданный ей ключ со списком обрабатываемых скриптом ключей. Если переданное значение нашлось в этом списке, выполняется соответствующая ветвь кода. Если при вызове скрипта будет использован любой ключ, обработка которого не предусмотрена, будет исполнена ветвь «\*».  
  

## Как различать ключи и параметры

  
Часто при написании bash-скриптов возникает ситуация, когда надо использовать и параметры командной строки, и ключи. Стандартный способ это сделать заключается в применении специальной последовательности символов, которая сообщает скрипту о том, когда заканчиваются ключи и начинаются обычные параметры.  
  
Эта последовательность — двойное тире (--). Оболочка использует её для указания позиции, на которой заканчивается список ключей. После того, как скрипт обнаружит признак окончания ключей, то, что осталось, можно, не опасаясь ошибок, обрабатывать как параметры, а не как ключи. Рассмотрим пример:  
  

```bash
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option" ;;
-b) echo "Found the -b option";;
-c) echo "Found the -c option" ;;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in $@
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

  
Этот сценарий использует команду`break`для прерывания цикла`while`при обнаружении в строке двойного тире.  
  
Вот что получится после его вызова.  
  

![](/images/e06806fe1b4bb8c750896fdaa3767f4a.png)

  
_Обработка ключей и параметров командной строки_  
  
Как видно, когда скрипт, разбирая переданные ему данные, находит двойное тире, он завершает обработку ключей и считает всё, что ещё не обработано, параметрами.  
  

## Обработка ключей со значениями

  
По мере усложнения ваших скриптов, вы столкнётесь с ситуациями, когда обычных ключей уже недостаточно, а значит, нужно будет использовать ключи с некими значениями. Например, вызов сценария в котором используется подобная возможность, выглядит так:  
  

```
./myscript -a test1 -b -c test2
```

  
Скрипт должен уметь определять, когда вместе с ключами командной строки используются дополнительные параметры:  
  

```bash
#!/bin/bash
while [ -n "$1" ]
do
case "$1" in
-a) echo "Found the -a option";;
-b) param="$2"
echo "Found the -b option, with parameter value $param"
shift ;;
-c) echo "Found the -c option";;
--) shift
break ;;
*) echo "$1 is not an option";;
esac
shift
done
count=1
for param in "$@"
do
echo "Parameter #$count: $param"
count=$(( $count + 1 ))
done
```

  
Вызовем этот скрипт в таком виде:  
  

```
./myscript -a -b test1 -d
```

  
Посмотрим на результаты его работы.  
  

![](/images/8a8867258b53425258e90111f9763ddb.png)

  
_Обработка параметров ключей_  
  
В данном примере в конструкции`case`обрабатываются три ключа. Ключ`-b`требует наличия дополнительного параметра. Так как обрабатываемый ключ находится в переменной`$1`, соответствующий ему параметр будет находиться в`$2`(тут используется команда`shift`, поэтому, по мере обработки, всё, что передано сценарию, сдвигается влево). Когда с этим мы разобрались, осталось лишь извлечь значение переменной`$2`и у нас будет параметр нужного ключа. Конечно, тут понадобится ещё одна команда`shift`для того, чтобы следующий ключ попал в`$1`.  
  

## Использование стандартных ключей

  
При написании bash-скриптов вы можете выбирать любые буквы для ключей командной строки и произвольно задавать реакцию скрипта на эти ключи. Однако, в мире Linux значения некоторых ключей стали чем-то вроде стандарта, которого полезно придерживаться. Вот список этих ключей:  
  

> `-a` Вывести все объекты.  
> `-c` Произвести подсчёт.  
> `-d` Указать директорию.  
> `-e` Развернуть объект.  
> `-f` Указать файл, из которого нужно прочитать данные.  
> `-h` Вывести справку по команде.  
> `-i` Игнорировать регистр символов.  
> `-l` Выполнить полноформатный вывод данных.  
> `-n` Использовать неинтерактивный (пакетный) режим.  
> `-o` Позволяет указать файл, в который нужно перенаправить вывод.  
> `-q` Выполнить скрипт в quiet-режиме.  
> `-r` Обрабатывать папки и файлы рекурсивно.  
> `-s` Выполнить скрипт в silent-режиме.  
> `-v` Выполнить многословный вывод.  
> `-x` Исключить объект.  
> `-y` Ответить «yes» на все вопросы.

  
Если вы работаете в Linux, вам, скорее всего, знакомы многие из этих ключей. Использовав их в общепринятом значении в своих скриптах, вы поможете пользователям взаимодействовать с ними, не беспокоясь о чтении документации.  
  

## Получение данных от пользователя

  
Ключи и параметры командной строки — это отличный способ получить данные от того, кто пользуется скриптом, однако в некоторых случаях нужно больше интерактивности.  
  
Иногда сценарии нуждаются в данных, которые пользователь должен ввести во время выполнения программы. Именно для этой цели в оболочке bash имеется команда`read`.  
  
Эта команда позволяет принимать введённые данные либо со стандартного ввода (с клавиатуры), либо используя другие дескрипторы файлов. После получения данных, эта команда помещает их в переменную:  
  

```bash
#!/bin/bash
echo -n "Enter your name: "
read name
echo "Hello $name, welcome to my program."
```

  
Обратите внимание на то, что команда `echo`, которая выводит приглашение, вызывается с ключом `-n`. Это приводит к тому, что в конце приглашения не выводится знак перевода строки, что позволяет пользователю скрипта вводить данные там же, где расположено приглашение, а не на следующей строке.  
  

![](/images/53d1ca2de0cdddb76571125d44c79697.png)

  
_Обработка пользовательского ввода_  
  
При вызове`read`можно указывать и несколько переменных:  
  

```bash
#!/bin/bash
read -p "Enter your name: " first last
echo "Your data for $last, $first…"
```

  
Вот что выведет скрипт после запуска.  
  

![](/images/db7d564840726149b098fad0545da7e6.png)

  
_Несколько переменных в команде read_  
  
Если, вызвав `read`, не указывать переменную, данные, введённые пользователем, будут помещены в специальную переменную среды `REPLY`:  
  

```bash
#!/bin/bash
read -p "Enter your name: "
echo Hello $REPLY, welcome to my program.
```

  

![](/images/e7afae7525869d3a0d64ec8d99637fda.png)

  
_Использование переменной среды REPLY_  
  
Если скрипт должен продолжать выполнение независимо от того, введёт пользователь какие-то данные или нет, вызывая команду `read` можно воспользоваться ключом `-t`. А именно, параметр ключа задаёт время ожидания ввода в секундах:  
  

```bash
#!/bin/bash
if read -t 5 -p "Enter your name: " name
then
echo "Hello $name, welcome to my script"
else
echo "Sorry, too slow! "
fi
```

  
Если данные не будут введены в течение 5 секунд, скрипт выполнит ветвь условного оператора `else`, выведя извинения.  
  

![](/images/65c68e9078b67feec2bbddd94c3729b9.png)

  
_Ограничение времени на ввод данных_  
  

## Ввод паролей

  
Иногда то, что вводит пользователь в ответ на вопрос скрипта, лучше на экране не показывать. Например, так обычно делают, запрашивая пароли. Ключ `-s` команды `read` предотвращает отображение на экране данных, вводимых с клавиатуры. На самом деле, данные выводятся, но команда`read`делает цвет текста таким же, как цвет фона.  
  

```bash
#!/bin/bash
read -s -p "Enter your password: " pass
echo "Is your password really $pass? "
```

  
Вот как отработает этот скрипт.  
  

![](/images/3c3fd43bd63034b4d7dc7159ad06da75.png)

  
_Ввод конфиденциальных данных_  
  

## Чтение данных из файла

  
Команда`read`может, при каждом вызове, читать одну строку текста из файла. Когда в файле больше не останется непрочитанных строк, она просто остановится. Если нужно получить в скрипте всё содержимое файла, можно, с помощью конвейера, передать результаты вызова команды`cat`для файла, конструкции`while`, которая содержит команду`read`(конечно, использование команды`cat`выглядит примитивно, но наша цель — показать всё максимально просто, ориентируясь на новичков; опытные пользователи, уверены, это поймут).  
  
Напишем скрипт, в котором используется только что описанный подход к чтению файлов.  
  

```bash
#!/bin/bash
count=1
cat myfile | while read line
do
echo "Line $count: $line"
count=$(( $count + 1 ))
done
echo "Finished"
```

  
Посмотрим на него в деле.  
  

![](/images/89324607c6c7c11435ad782d88950d6f.png)

  
_Чтение данных из файла_  
  
Тут мы передали в цикл `while` содержимое файла и перебрали все строки этого файла, выводя номер и содержимое каждой из них.

# Bash-скрипты, часть 4: ввод и вывод

## Стандартные дескрипторы файлов

  
Всё в Linux — это файлы, в том числе — ввод и вывод. Операционная система идентифицирует файлы с использованием дескрипторов.  
  
Каждому процессу позволено иметь до девяти открытых дескрипторов файлов. Оболочка bash резервирует первые три дескриптора с идентификаторами 0, 1 и 2. Вот что они означают.  
  

*   `0`,`STDIN` — стандартный поток ввода.
*   `1`,`STDOUT` — стандартный поток вывода.
*   `2`,`STDERR` — стандартный поток ошибок.

  
Эти три специальных дескриптора обрабатывают ввод и вывод данных в сценарии.  
Вам нужно как следует разобраться в стандартных потоках. Их можно сравнить с фундаментом, на котором строится взаимодействие скриптов с внешним миром. Рассмотрим подробности о них.  
  

## STDIN

  
`STDIN` — это стандартный поток ввода оболочки. Для терминала стандартный ввод — это клавиатура. Когда в сценариях используют символ перенаправления ввода — `<`, Linux заменяет дескриптор файла стандартного ввода на тот, который указан в команде. Система читает файл и обрабатывает данные так, будто они введены с клавиатуры.  
  
Многие команды bash принимают ввод из `STDIN`, если в командной строке не указан файл, из которого надо брать данные. Например, это справедливо для команды `cat`.  
  
Когда вы вводите команду `cat` в командной строке, не задавая параметров, она принимает ввод из `STDIN`. После того, как вы вводите очередную строку, `cat` просто выводит её на экран.  
  

## STDOUT

  
`STDOUT` — стандартный поток вывода оболочки. По умолчанию это — экран. Большинство bash-команд выводят данные в `STDOUT`, что приводит к их появлению в консоли. Данные можно перенаправить в файл, присоединяя их к его содержимому, для этого служит команда `>>`.  
  
Итак, у нас есть некий файл с данными, к которому мы можем добавить другие данные с помощью этой команды:  
  

```bash
pwd >> myfile
```

  
То, что выведет`pwd`, будет добавлено к файлу`myfile`, при этом уже имеющиеся в нём данные никуда не денутся.  
  

![](/images/MT_u64e-cQwiS9VlBwtI0AfCRZ7KlpkMOwGpc7Xp6e-ckueCQDeO8cptohQVGRVNz9B5a8oHtqTnUBM9EcXQ7PzGSS3quPbBLNaxNjZum_pTfrOOTYj2ULQr0jlMcaPZCcx-80VO8k1EUL5B8Q)

  
_Перенаправление вывода команды в файл_  
  
Пока всё хорошо, но что если попытаться выполнить что-то вроде показанного ниже, обратившись к несуществующему файлу`xfile`, задумывая всё это для того, чтобы в файл`myfile`попало сообщение об ошибке.  
  

```bash
ls –l xfile > myfile
```

  
После выполнения этой команды мы увидим сообщения об ошибках на экране.  
  

![](/images/xkDHMNwO2v8IG9lBR5GZZ-MuiHIOn9c53-l_XbXvijkCdhM15yCA0Nndl_uHDPif1Y1MxUgy_5JrBv9Wquc6DSrbTRXNzsRf5VsoeFghoVXf8k-NGVdZLhQFYmnr2JeZ5SYDq_BhHacvCXs5nw)

  
_Попытка обращения к несуществующему файлу_  
  
При попытке обращения к несуществующему файлу генерируется ошибка, но оболочка не перенаправила сообщения об ошибках в файл, выведя их на экран. Но мы-то хотели, чтобы сообщения об ошибках попали в файл. Что делать? Ответ прост — воспользоваться третьим стандартным дескриптором.  
  

## STDERR

  
`STDERR`представляет собой стандартный поток ошибок оболочки. По умолчанию этот дескриптор указывает на то же самое, на что указывает`STDOUT`, именно поэтому при возникновении ошибки мы видим сообщение на экране.  
  
Итак, предположим, что надо перенаправить сообщения об ошибках, скажем, в лог-файл, или куда-нибудь ещё, вместо того, чтобы выводить их на экран.  
  

### Перенаправление потока ошибок

  
Как вы уже знаете, дескриптор файла`STDERR —`2\. Мы можем перенаправить ошибки, разместив этот дескриптор перед командой перенаправления:  
  

```bash
ls -l xfile 2>myfile
cat ./myfile
```

  
Сообщение об ошибке теперь попадёт в файл`myfile`.  
  

![](/images/2KC8_kWlp5a15ruyBlvN8RkdX9Sncf8RztKz55HgpGesffvbK8wQW2MEoaCjEJRB97Tq3IU4KTzGhmz7oARoisV8ShxFHCAJTb1pkJuZwmLI_bfjeGZyALBQdSPOfFMkyOCVgnk-zDqPN9QFEA)

  
_Перенаправление сообщения об ошибке в файл_  
  

### Перенаправление потоков ошибок и вывода

  
При написании сценариев командной строки может возникнуть ситуация, когда нужно организовать и перенаправление сообщений об ошибках, и перенаправление стандартного вывода. Для того, чтобы этого добиться, нужно использовать команды перенаправления для соответствующих дескрипторов с указанием файлов, куда должны попадать ошибки и стандартный вывод:  
  

```bash
ls –l myfile xfile anotherfile 2> errorcontent 1> correctcontent
```

  

![](/images/oqXLEuYY5u6b5m6-FgwkG-YG2DIHOAjFMT-vYFQytzLMZJAxUy7DuCleOHeFZKTeV2kEmoVMdhGMb7MjNTjtVDA-4uYv2RZc8g_kpo5QcSjPIKexL8xLDqK5-aOEoOMaL98D7hao0GOUDerW2Q)

  
_Перенаправление ошибок и стандартного вывода_  
  
Оболочка перенаправит то, что команда`ls`обычно отправляет в`STDOUT`, в файл`correctcontent`благодаря конструкции`1>`. Сообщения об ошибках, которые попали бы в`STDERR`, оказываются в файле`errorcontent`из-за команды перенаправления`2>`.  
  
Если надо, и`STDERR`, и`STDOUT`можно перенаправить в один и тот же файл, воспользовавшись командой`&>`:  
  

![](/images/2938XZKz95Stm-lttdbvTf6yaz-io5o8Wt5xlCmdsrvQRUcQ27HKX2ETI89QA6wxonMzWiCqdFMlOU0Z8q-hrf0P0EaSXXlx9z0rBLyzszL-6D8IBoXwiVxFXZtayXPiUJ29llCBdOdXp38JMA)

  
_Перенаправление STDERR и STDOUT в один и тот же файл_  
  
После выполнения команды то, что предназначено для`STDERR`и`STDOUT`, оказывается в файле`content`.  
  

## Перенаправление вывода в скриптах

  
Существует два метода перенаправления вывода в сценариях командной строки:  
  

*   Временное перенаправление, или перенаправление вывода одной строки.
*   Постоянное перенаправление, или перенаправление всего вывода в скрипте либо в какой-то его части.

  

### Временное перенаправление вывода

  
В скрипте можно перенаправить вывод отдельной строки в`STDERR`. Для того, чтобы это сделать, достаточно использовать команду перенаправления, указав дескриптор`STDERR`, при этом перед номером дескриптора надо поставить символ амперсанда (`&`):  
  

```bash
#!/bin/bash
echo "This is an error" >&2
echo "This is normal output"
```

  
Если запустить скрипт, обе строки попадут на экран, так как, как вы уже знаете, по умолчанию ошибки выводятся туда же, куда и обычные данные.  
  

![](/images/vZui5QFtOOOwTKR5duEthXs3sKEOK31e85_FuQ9ygfVo1GXH3ojQDKYizQSv_XYC7pVXPGAhJRXp9keiz6JEX7ZMYL838xfNQXxrZ-HnlGGuA8iu95mx88pEmwlSWTNNX4vzNrjb2ZQeR68IRw)

  
_Временное перенаправление_  
  
Запустим скрипт так, чтобы вывод`STDERR`попадал в файл.  
  

```
./myscript 2> myfile
```

  
Как видно, теперь обычный вывод делается в консоль, а сообщения об ошибках попадают в файл.  
  

![](/images/FLgdZTOJynq_Uigre-Mclmf6ESccvVebTBczs-tkDSaeSs6eZQI4i-q4vFqQI9J-2NYva8l2X-tNjQAolqKbvtXhuxHi4ZYadtp1at0eOTstD7mVy13VD6TOPr_mm5NGtiZL57P2eLhL6gKM2A)

  
_Сообщения об ошибках записываются в файл_  
  

### Постоянное перенаправление вывода

  
Если в скрипте нужно перенаправлять много выводимых на экран данных, добавлять соответствующую команду к каждому вызову`echo`неудобно. Вместо этого можно задать перенаправление вывода в определённый дескриптор на время выполнения скрипта, воспользовавшись командой`exec`:  
  

```bash
#!/bin/bash
exec 1>outfile
echo "This is a test of redirecting all output"
echo "from a shell script to another file."
echo "without having to redirect every line"
```

  
Запустим скрипт.  
  

![](/images/bsfDHNdPnsaOMIUZuqpOeUzyiJvmNFqmLFSEnnnKIWAlGsGfMPxxTQclRZcp1IuPtYwfQPB0gePTWAzwhixTPElZfm-0l4u7qlh6s9XghFXDN2ABawkhyd136HO2K1oQCXtPonUxzYbPTCmIsQ)

  
_Перенаправление всего вывода в файл_  
  
Если просмотреть файл, указанный в команде перенаправления вывода, окажется, что всё, что выводилось командами`echo`, попало в этот файл.  
  
Команду`exec`можно использовать не только в начале скрипта, но и в других местах:  
  

```bash
#!/bin/bash
exec 2>myerror
echo "This is the start of the script"
echo "now redirecting all output to another location"
exec 1>myfile
echo "This should go to the myfile file"
echo "and this should go to the myerror file" >&2
```

  
Вот что получится после запуска скрипта и просмотра файлов, в которые мы перенаправляли вывод.  
  

![](/images/pkDrsO-90p-aoSP2NngxJsK7X1PxdZEAX_SC6xgcz7R_VhIm-kWzm3B-1virrHcZ_uMDBlCPR3vsEpf7_LbSTH1V9V9Vlh8WZxK38ERpgcJGvpz19w6b0cpCdTcGwUEx65FdkIf7r6fzwGiGbA)

  
_Перенаправление вывода в разные файлы_  
  
Сначала команда`exec`задаёт перенаправление вывода из`STDERR`в файл`myerror`. Затем вывод нескольких команд`echo`отправляется в`STDOUT`и выводится на экран. После этого команда`exec`задаёт отправку того, что попадает в`STDOUT`, в файл`myfile`, и, наконец, мы пользуемся командой перенаправления в`STDERR`в команде`echo`, что приводит к записи соответствующей строки в файл`myerror.`  
  
Освоив это, вы сможете перенаправлять вывод туда, куда нужно. Теперь поговорим о перенаправлении ввода.  
  

## Перенаправление ввода в скриптах

  
Для перенаправления ввода можно воспользоваться той же методикой, которую мы применяли для перенаправления вывода. Например, команда`exec`позволяет сделать источником данных для`STDIN`какой-нибудь файл:  
  

```bash
exec 0< myfile
```

  
Эта команда указывает оболочке на то, что источником вводимых данных должен стать файл`myfile`, а не обычный`STDIN`. Посмотрим на перенаправление ввода в действии:  
  

```bash
#!/bin/bash
exec 0< testfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
```

  
Вот что появится на экране после запуска скрипта.  
  

![](/images/eDQbaQ1jCzG8iB-HXt0r2LBtZryyGj3aRdnxjN4hmfDZvDWV1zJqMzlz7hFyCX692MWJTKbDSSt81xTpGPLLqndZwmAvs_rYfPWQMTMOQHKJZ3SqB9pOo9T09dFUr5AD2sZw64D-DK4Hl7DIBg)

  
_Перенаправление ввода_  
  
В одном из предыдущих материалов вы узнали о том, как использовать команду`read`для чтения данных, вводимых пользователем с клавиатуры. Если перенаправить ввод, сделав источником данных файл, то команда`read`, при попытке прочитать данные из`STDIN`, будет читать их из файла, а не с клавиатуры.  
  
Некоторые администраторы Linux используют этот подход для чтения и последующей обработки лог-файлов.  
  

## Создание собственного перенаправления вывода

  
Перенаправляя ввод и вывод в сценариях, вы не ограничены тремя стандартными дескрипторами файлов. Как уже говорилось, можно иметь до девяти открытых дескрипторов. Остальные шесть, с номерами от 3 до 8, можно использовать для перенаправления ввода или вывода. Любой из них можно назначить файлу и использовать в коде скрипта.  
  
Назначить дескриптор для вывода данных можно, используя команду`exec`:  
  

```bash
#!/bin/bash
exec 3>myfile
echo "This should display on the screen"
echo "and this should be stored in the file" >&3
echo "And this should be back on the screen"
```

  
После запуска скрипта часть вывода попадёт на экран, часть — в файл с дескриптором`3`.  
  

![](/images/faCFAF7pvOg4Gb_2u4MHOcUvGsZUj3nmaFNM3I96ohph7I4eG8ax3u2w4Nf3blBSSWTEdrzxTftzyzCafYxDj7aS3LNVMd2sJxAjC9ztn4tFW9OVN8HM0OHXYUvE3WrktWUgWcByzBUAIIo2wQ)

  
_Перенаправление вывода, используя собственный дескриптор_  
  

## Создание дескрипторов файлов для ввода данных

  
Перенаправить ввод в скрипте можно точно так же, как и вывод. Сохраните`STDIN`в другом дескрипторе, прежде чем перенаправлять ввод данных.  
  
После окончания чтения файла можно восстановить`STDIN`и пользоваться им как обычно:  
  

```bash
#!/bin/bash
exec 6<&0
exec 0< myfile
count=1
while read line
do
echo "Line #$count: $line"
count=$(( $count + 1 ))
done
exec 0<&6
read -p "Are you done now? " answer
case $answer in
y) echo "Goodbye";;
n) echo "Sorry, this is the end.";;
esac
```

  
Испытаем сценарий.  
  

![](/images/ASf0YHSBrC-5W-uhWf8914FSGhA4u5u59NrqTPt2dpifIGNJ-Fpj9OAK_XfauzkpxaOU8729wEr-177L6ujoXnvFv1PiBaOWlXLwleUVzV9IEFdX8rgrMB7D0cto20j1egBlyn5qT0oDg4fLeQ)

  
_Перенаправление ввода_  
  
В этом примере дескриптор файла 6 использовался для хранения ссылки на`STDIN`. Затем было сделано перенаправление ввода, источником данных для`STDIN`стал файл. После этого входные данные для команды`read`поступали из перенаправленного`STDIN`, то есть из файла.  
  
После чтения файла мы возвращаем`STDIN`в исходное состояние, перенаправляя его в дескриптор`6`. Теперь, для того, чтобы проверить, что всё работает правильно, скрипт задаёт пользователю вопрос, ожидает ввода с клавиатуры и обрабатывает то, что введено.  
  

## Закрытие дескрипторов файлов

  
Оболочка автоматически закрывает дескрипторы файлов после завершения работы скрипта. Однако, в некоторых случаях нужно закрывать дескрипторы вручную, до того, как скрипт закончит работу. Для того, чтобы закрыть дескриптор, его нужно перенаправить в`&-`. Выглядит это так:  
  

```bash
#!/bin/bash
exec 3> myfile
echo "This is a test line of data" >&3
exec 3>&-
echo "This won't work" >&3
```

  
После исполнения скрипта мы получим сообщение об ошибке.  
  

![](/images/-yp803VfhFjaIy1RDFQKeJedQMrbGdJxyvcU_Iikdx8eQoZBET64TioTH4hiejpdx6c4GxauOYTwgal2g1I7O8jX59attXzWAcu3DH2lMAgF7I8QLVfCVS_a9hI3lWKRQX9jayVbG5fJ8EJXzw)

  
_Попытка обращения к закрытому дескриптору файла_  
  
Всё дело в том, что мы попытались обратиться к несуществующему дескриптору.  
  
Будьте внимательны, закрывая дескрипторы файлов в сценариях. Если вы отправляли данные в файл, потом закрыли дескриптор, потом — открыли снова, оболочка заменит существующий файл новым. То есть всё то, что было записано в этот файл ранее, будет утеряно.  
  

## Получение сведений об открытых дескрипторах

  
Для того, чтобы получить список всех открытых в Linux дескрипторов, можно воспользоваться командой`lsof`. Во многих дистрибутивах, вроде Fedora, утилита`lsof`находится в`/usr/sbin`. Эта команда весьма полезна, так как она выводит сведения о каждом дескрипторе, открытом в системе. Сюда входит и то, что открыли процессы, выполняемые в фоне, и то, что открыто пользователями, вошедшими в систему.  
  
У этой команды есть множество ключей, рассмотрим самые важные.  
  

*   `-p` Позволяет указать `ID` процесса.
*   `-d` Позволяет указать номер дескриптора, о котором надо получить сведения.

  
Для того, чтобы узнать`PID`текущего процесса, можно использовать специальную переменную окружения`$$`, в которую оболочка записывает текущий`PID`.  
  
Ключ`-a`используется для выполнения операции логического`И`над результатами, возвращёнными благодаря использованию двух других ключей:  
  

```bash
lsof -a -p $$ -d 0,1,2
```

  

![](/images/pZmbYEv-md9wDFqCgKHxOE24vVVhyliwk862ye4V8DAMtXt0JovYi1Eo0QtTE_ruiSZEeTqZmJOze3I_ni1KQfG6SkSs991adZs9zAK-dc77pE1bpSebhyay2FJPBJdck5EPFqSzBXmmn5wVXA)

  
_Вывод сведений об открытых дескрипторах_  
  
Тип файлов, связанных с`STDIN`,`STDOUT`и`STDERR —`CHR (character mode, символьный режим). Так как все они указывают на терминал, имя файла соответствует имени устройства, назначенного терминалу. Все три стандартных файла доступны и для чтения, и для записи.  
  
Посмотрим на вызов команды`lsof`из скрипта, в котором открыты, в дополнение к стандартным, другие дескрипторы:  
  

```bash
#!/bin/bash
exec 3> myfile1
exec 6> myfile2
exec 7< myfile3
lsof -a -p $$ -d 0,1,2,3,6,7
```

  
Вот что получится, если этот скрипт запустить.  
  

![](/images/RPDfGTvjcpMfZKDMMUOrONU3B12jZhXnTzZlcfuFttnojMNrdCenJFrgZMTyZXfdU4Vj2GErTVGXTwvrtEbdYxkpjLoL0gHDfXwv2cX2fHjHEnH0Bnp-bQDHjDG5QU3xXBWAHcU-qYLP_c4f8g)

  
_Просмотр дескрипторов файлов, открытых скриптом_  
  
Скрипт открыл два дескриптора для вывода (`3`и`6`) и один — для ввода (`7`). Тут же показаны и пути к файлам, использованных для настройки дескрипторов.  
  

## Подавление вывода

  
Иногда надо сделать так, чтобы команды в скрипте, который, например, может исполняться как фоновый процесс, ничего не выводили на экран. Для этого можно перенаправить вывод в `/dev/null`. Это — что-то вроде «чёрной дыры».  
  
Вот, например, как подавить вывод сообщений об ошибках:  
  

```bash
ls -al badfile anotherfile 2> /dev/null
```

  
Тот же подход используется, если, например, надо очистить файл, не удаляя его:  
  

```bash
cat /dev/null > myfile
```

# Bash-скрипты, часть 5: сигналы, фоновые задачи, управление сценариями

## Сигналы Linux

  
В Linux существует более трёх десятков сигналов, которые генерирует система или приложения. Вот список наиболее часто используемых, которые наверняка пригодятся при разработке сценариев командной строки.  

<table style="margin: 1.5em 0px; width: 779px; border: 1px solid rgb(213, 221, 223); border-collapse: collapse; color: rgb(34, 34, 34); font-family: -apple-system, BlinkMacSystemFont, Arial, sans-serif; font-size: 16px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"><tbody><tr><td width="120" style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;"><b style="font-weight: bolder;">Код сигнала</b><br></td><td width="100" style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;"><b style="font-weight: bolder;">Название</b><br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;"><b style="font-weight: bolder;">Описание</b><br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">1<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGHUP<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Закрытие терминала<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">2<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGINT<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Сигнал остановки процесса пользователем с терминала (CTRL + C)<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">3<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGQUIT<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Сигнал остановки процесса пользователем с терминала (CTRL + \) с дампом памяти<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">9<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGKILL<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Безусловное завершение процесса<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">15<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGTERM<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Сигнал запроса завершения процесса<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">17<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGSTOP<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Принудительная приостановка выполнения процесса, но не завершение его работы<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">18<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGTSTP<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Приостановка процесса с терминала (CTRL + Z), но не завершение работы<br></td></tr><tr><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">19<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">SIGCONT<br></td><td style="padding: 6px 12px 9px; border: 1px solid rgb(213, 221, 223); vertical-align: top; line-height: 1.5;">Продолжение выполнения ранее остановленного процесса<br></td></tr></tbody></table>

  
Если оболочка bash получает сигнал`SIGHUP`когда вы закрываете терминал, она завершает работу. Перед выходом она отправляет сигнал`SIGHUP`всем запущенным в ней процессам, включая выполняющиеся скрипты.  
  
Сигнал`SIGINT`приводит к временной остановке работы. Ядро Linux перестаёт выделять оболочке процессорное время. Когда это происходит, оболочка уведомляет процессы, отправляя им сигнал`SIGINT`.  
  
Bash-скрипты не контролируют эти сигналы, но они могут распознавать их и выполнять некие команды для подготовки скрипта к последствиям, вызываемым сигналами.  
  

## Отправка сигналов скриптам

  
Оболочка bash позволяет вам отправлять скриптам сигналы, пользуясь комбинациями клавиш на клавиатуре. Это оказывается очень кстати если нужно временно остановить выполняющийся скрипт или завершить его работу.  
  

### Завершение работы процесса

  
Комбинация клавиш`CTRL + C`генерирует сигнал`SIGINT`и отправляет его всем процессам, выполняющимся в оболочке, что приводит к завершению их работы.  
  
Выполним в оболочке такую команду:  
  

```console
$ sleep 100
```

  
После этого завершим её работу комбинацией клавиш`CTRL + C`.  
  

![](/images/9376fa3d5c77d38976f575f4bef8b2c2.png)

  
_Завершение работы процесса с клавиатуры_  
  

### Временная остановка процесса

  
Комбинация клавиш`CTRL + Z`позволяет сгенерировать сигнал`SIGTSTP`, который приостанавливает работу процесса, но не завершает его выполнение. Такой процесс остаётся в памяти, его работу можно возобновить. Выполним в оболочке команду:  
  

```console
$ sleep 100
```

  
И временно остановим её комбинацией клавиш`CTRL + Z`.  
  

![](/images/b590cd419f80c0561924073eb776ee1e.png)

  
_Приостановка процесса_  
  
Число в квадратных скобках — это номер задания, который оболочка назначает процессу. Оболочка рассматривает процессы, выполняющиеся в ней, как задания с уникальными номерами. Первому процессу назначается номер 1, второму — 2, и так далее.  
  
Если вы приостановите задание, привязанное к оболочке, и попытаетесь выйти из неё, bash выдаст предупреждение.  
  
Просмотреть приостановленные задания можно такой командой:  
  

```
ps –l
```

  

![](/images/cb587e940d70ca8d553b89eeaca21f79.png)

  
_Список заданий_  
  
В колонке`S`, выводящей состояние процесса, для приостановленных процессов выводится`T`. Это указывает на то, что команда либо приостановлена, либо находится в состоянии трассировки.  
  
Если нужно завершить работу приостановленного процесса, можно воспользоваться командой`kill`. Подробности о ней можно почитать[здесь](https://likegeeks.com/main-linux-commands-easy-guide/).  
  
Выглядит её вызов так:  
  

```
kill processID
```

  

## Перехват сигналов

  
Для того, чтобы включить в скрипте отслеживание сигналов Linux, используется команда`trap`. Если скрипт получает сигнал, указанный при вызове этой команды, он обрабатывает его самостоятельно, при этом оболочка такой сигнал обрабатывать не будет.  
  
Команда`trap`позволяет скрипту реагировать на сигналы, в противном случае их обработка выполняется оболочкой без его участия.  
  
Рассмотрим пример, в котором показано, как при вызове команды`trap`задаётся код, который надо выполнить, и список сигналов, разделённых пробелами, которые мы хотим перехватить. В данном случае это всего один сигнал:  
  

```bash
#!/bin/bash
trap "echo ' Trapped Ctrl-C'" SIGINT
echo This is a test script
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
```

  
Команда`trap`, использованная в этом примере, выводит текстовое сообщение всякий раз, когда она обнаруживает сигнал`SIGINT`, который можно сгенерировать, нажав`Ctrl + C`на клавиатуре.  
  

![](/images/83d18cae50802de6c4d705c36637c3b0.png)

  
_Перехват сигналов_  
  
Каждый раз, когда вы нажимаете клавиши`CTRL + C`, скрипт выполняет команду`echo`, указанную при вызове`trace`вместо того, чтобы позволить оболочке завершит его работу.  
  

## Перехват сигнала выхода из скрипта

  
Перехватить сигнал выхода из скрипта можно, использовав при вызове команды`trap`имя сигнала`EXIT`:  
  

```bash
#!/bin/bash
trap "echo Goodbye..." EXIT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
```

  

![](/images/7bbeb3f1d02a61f02878cc119a1c1076.png)

  
_Перехват сигнала выхода из скрипта_  
  
При выходе из скрипта, будь то нормальное завершение его работы или завершение, вызванное сигналом`SIGINT`, сработает перехват и оболочка исполнит команду`echo`.  
  

## Модификация перехваченных сигналов и отмена перехвата

  
Для модификации перехваченных скриптом сигналов можно выполнить команду`trap`с новыми параметрами:  
  

```bash
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
trap "echo ' I modified the trap!'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Second Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
```

  

![](/images/916a7a72e1abdfc4dc5126ad031c601f.png)

  
_Модификация перехвата сигналов_  
  
После модификации сигналы будут обрабатываться по-новому.  
  
Перехват сигналов можно и отменить, для этого достаточно выполнить команду`trap`, передав ей двойное тире и имя сигнала:  
  

```bash
#!/bin/bash
trap "echo 'Ctrl-C is trapped.'" SIGINT
count=1
while [ $count -le 5 ]
do
echo "Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
trap -- SIGINT
echo "I just removed the trap"
count=1
while [ $count -le 5 ]
do
echo "Second Loop #$count"
sleep 1
count=$(( $count + 1 ))
done
```

  
Если скрипт получит сигнал до отмены перехвата, он обработает его так, как задано в действующей команде`trap`. Запустим скрипт:  
  

```console
$ ./myscript
```

  
И нажмём`CTRL + C`на клавиатуре.  
  

![](/images/9df19861e4a635dcd0e3dcfb6a48bdeb.png)

  
_Сигнал, перехваченный до отмены перехвата_  
  
Первое нажатие`CTRL + C`пришлось на момент исполнения скрипта, когда перехват сигнала был в силе, поэтому скрипт исполнил назначенную сигналу команду`echo`. После того, как исполнение дошло до команды отмены перехвата, команда`CTRL + C`сработала обычным образом, завершив работу скрипта.  
  

## Выполнение сценариев командной строки в фоновом режиме

  
Иногда bash-скриптам требуется немало времени для выполнения некоей задачи. При этом вам может понадобиться возможность нормально работать в командной строке, не дожидаясь завершения скрипта. Реализовать это не так уж и сложно.  
  
Если вы видели список процессов, выводимый командой`ps`, вы могли заметить процессы, которые выполняются в фоне и не привязаны к терминалу.  
Напишем такой скрипт:  
  

```bash
#!/bin/bash
count=1
while [ $count -le 10 ]
do
sleep 1
count=$(( $count + 1 ))
done
```

  
Запустим его, указав после имени символ амперсанда (`&`):  
  

```console
$ ./myscipt &
```

  
Это приведёт к тому, что он будет запущен как фоновый процесс.  
  

![](/images/b695f0b34f4569d1bacf26e43320dba9.png)

  
_Запуск скрипта в фоновом режиме_  
  
Скрипт будет запущен в фоновом процессе, в терминал выведется его идентификатор, а когда его выполнение завершится, вы увидите сообщение об этом.  
  
Обратите внимание на то, что хотя скрипт выполняется в фоне, он продолжает использовать терминал для вывода сообщений в`STDOUT`и`STDERR`, то есть, выводимый им текст или сообщения об ошибках можно будет увидеть в терминале.  
  

![](/images/2da419a3df3716a57b260cea3ae2458e.png)

  
_Список процессов_  
  
При таком подходе, если выйти из терминала, скрипт, выполняющийся в фоне, так же завершит работу.  
  
Что если нужно, чтобы скрипт продолжал работать и после закрытия терминала?  
  

## Выполнение скриптов, не завершающих работу при закрытии терминала

  
Скрипты можно выполнять в фоновых процессах даже после выхода из терминальной сессии. Для этого можно воспользоваться командой`nohup`. Эта команда позволяет запустить программу, блокируя сигналы`SIGHUP`, отправляемые процессу. В результате процесс будет исполняться даже при выходе из терминала, в котором он был запущен.  
  
Применим эту методику при запуске нашего скрипта:  
  

```
nohup ./myscript &
```

  
Вот что будет выведено в терминал.  
  

![](/images/919b196174424f1f93d3f172d644980d.png)

  
_Команда nohup_  
  
Команда`nohup`отвязывает процесс от терминала. Это означает, что процесс потеряет ссылки на`STDOUT`и`STDERR`. Для того, чтобы не потерять данные, выводимые скриптом,`nohup`автоматически перенаправляет сообщения, поступающие в`STDOUT`и в`STDERR`, в файл`nohup.out`.  
  
Обратите внимание на то, что при запуске нескольких скриптов из одной и той же директории то, что они выводят, попадёт в один файл`nohup.out`.  
  

## Просмотр заданий

  
Команда`jobs`позволяет просматривать текущие задания, которые выполняются в оболочке. Напишем такой скрипт:  
  

```bash
#!/bin/bash
count=1
while [ $count -le 10 ]
do
echo "Loop #$count"
sleep 10
count=$(( $count + 1 ))
done
```

  
Запустим его:  
  

```console
$ ./myscript
```

  
И временно остановим комбинацией клавиш`CTRL + Z`.  
  

![](/images/e3934f505f0d1029a3cc706129ea6cd9.png)

  
_Запуск и приостановка скрипта_  
  
Запустим тот же скрипт в фоновом режиме, при этом перенаправим вывод скрипта в файл так, чтобы он ничего не выводил на экране:  
  

```console
$ ./myscript > outfile &
```

  
Выполнив теперь команду`jobs`, мы увидим сведения как о приостановленном скрипте, так и о том, который работает в фоне.  
  

![](/images/0ca9bb7f2f04c6a656ede99cb1365158.png)

  
_Получение сведений о скриптах_  
  
Ключ`-l`при вызове команды`jobs`указывает на то, что нам нужны сведения об`ID`процессов.  
  

## Перезапуск приостановленных заданий

  
Для того, чтобы перезапустить скрипт в фоновом режиме, можно воспользоваться командой`bg`.  
  
Запустим скрипт:  
  

```console
$ ./myscript
```

  
Нажмём`CTRL + Z`, что временно остановит его выполнение. Выполним следующую команду:  
  

```
$ bg
```

  

![](/images/105a1dbbd3148791c3259fd3ca66f10c.png)

  
_Команда bg_  
  
Теперь скрипт выполняется в фоновом режиме.  
  
Если у вас имеется несколько приостановленных заданий, для перезапуска конкретного задания команде`bg`можно передать его номер.  
  
Для перезапуска задания в обычном режиме воспользуйтесь командой`fg`:  
  

```console
$ fg 1
```

  

## Планирование запуска скриптов

  
Linux предоставляет пару способов запуска bash-скриптов в заданное время. Это команда`at`и планировщик заданий`cron`.  
  
Вызов команды at выглядит так:  
  

```
at [-f filename] time
```

  
Эта команда распознаёт множество форматов указания времени.  
  

*   Стандартный, с указанием часов и минут, например — 10:15.
*   С использованием индикаторов AM/PM, до или после полудня, например — 10:15PM.
*   С использованием специальных имён, таких, как`now`,`noon`,`midnight`.

  
В дополнение к возможности указания времени запуска задания, команде`at`можно передать и дату, используя один из поддерживаемых ей форматов.  
  

*   Стандартный формат указания даты, при котором дата записывается по шаблонам`MMDDYY`,`MM/DD/YY`, или`DD.MM.YY`.
*   Текстовое представление даты, например,`Jul 4`или`Dec 25`, при этом год можно указать, а можно обойтись и без него.
*   Запись вида`now + 25 minutes`.
*   Запись вида`10:15PM tomorrow`.
*   Запись вида`10:15 + 7 days`.

  
Не будем углубляться в эту тему, рассмотрим простой вариант использования команды:  
  

```console
$ at -f ./myscript now
```

  

![](/images/41b3df99c30ec2c689f435b03a249225.png)

  
_Планирование заданий с использованием команды at_  
  
Ключ`-M`при вызове`at`используется для отправки того, что выведет скрипт, по электронной почте, если система соответствующим образом настроена. Если отправка электронного письма невозможна, этот ключ просто подавит вывод.  
  
Для того чтобы посмотреть список заданий, ожидающих выполнения, можно воспользоваться командой`atq`:  
  

```console
$ atq
```

  

![](/images/b03cebbcef29c5e9532c6be32df21e34.png)

  
_Список заданий, ожидающих выполнения_  
  

## Удаление заданий, ожидающих выполнения

  
Удалить задание, ожидающее выполнения, позволяет команда`atrm`. При её вызове указывают номер задания:  
  

```console
$ atrm 18
```

  

![](/images/30ea3176f974fc0d9a8a9c56d465f908.png)

  
_Удаление задания_  
  

## Запуск скриптов по расписанию

  
Планирование однократного запуска скриптов с использованием команды`at`способно облегчить жизнь во многих ситуациях. Но как быть, если нужно, чтобы скрипт выполнялся в одно и то же время ежедневно, или раз в неделю, или раз в месяц?  
  
В Linux имеется утилита`crontab`, позволяющая планировать запуск скриптов, которые нужно выполнять регулярно.  
  
`Crontab`выполняется в фоне и, основываясь на данных в так называемых cron-таблицах, запускает задания по расписанию.  
  
Для того, чтобы просмотреть существующую таблицу заданий`cron`, воспользуйтесь такой командой:  
  

```
$ crontab –l
```

  
При планировании запуска скрипта по расписанию`crontab`принимает данные о том, когда нужно выполнить задание, в таком формате:  
  

```
минута, час, день месяца, месяц, день недели.
```

  
Например, если надо, чтобы некий скрипт с именем`command`выполнялся ежедневно в 10:30, этому будет соответствовать такая запись в таблице заданий:  
  

```
30 10 * * * command
```

  
Здесь универсальный символ «`*`», использованный для полей, задающих день месяца, месяц и день недели, указывает на то, что`cron`должен выполнять команду каждый день каждого месяца в 10:30.  
  
Если, например, надо, чтобы скрипт запускался в`4:30PM`каждый понедельник, понадобится создать в таблице заданий такую запись:  
  

```
30 16 * * 1 command
```

  
Нумерация дней недели начинается с 0, 0 означает воскресенье, 6 — субботу. Вот ещё один пример. Здесь команда будет выполняться в 12 часов дня в первый день каждого месяца.  
  

```
00 12 1 * * command
```

  
Нумерация месяцев начинается с 1.  
Для того чтобы добавить запись в таблицу, нужно вызвать`crontab`с ключом`-e`:  
  

```
crontab –e
```

  
Затем можно вводить команды формирования расписания:  
  

```
30 10 * * * /home/likegeeks/Desktop/myscript
```

  
Благодаря этой команде скрипт будет вызываться ежедневно в 10:30. Если вы столкнётесь с ошибкой «Resource temporarily unavailable», выполните нижеприведённую команду с правами root-пользователя:  
  

```console
$ rm -f /var/run/crond.pid
```

  
Организовать периодический запуск скриптов с использованием`cron`можно ещё проще, воспользовавшись несколькими специальными директориями:  
  

```
/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
```

  
Если поместить файл скрипта в одну из них, это приведёт, соответственно, к его ежечасному, ежедневному, еженедельному или ежемесячному запуску.  
  

## Запуск скриптов при входе в систему и при запуске оболочки

  
Автоматизировать запуск скриптов можно, опираясь на различные события, такие, как вход пользователя в систему или запуск оболочки.[Тут](https://likegeeks.com/linux-environment-variables/)можно почитать о файлах, которые обрабатываются в подобных ситуациях. Например, это следующие файлы:  
  

```bash
$HOME/.bash_profile
$HOME/.bash_login
$HOME/.profile
```

  
Для того, чтобы запускать скрипт при входе в систему, поместите его вызов в файл`.bash_profile`.  
  
А как насчёт запуска скриптов при открытии терминала? Организовать это поможет файл`.bashrc`.

# Bash-скрипты, часть 6: функции и разработка библиотек

## Объявление функций

  
Функцию можно объявить так:  
  

```bash
functionName {
}
```

  
Или так:  
  

```bash
functionName() {
}
```

  
Функцию можно вызвать без аргументов и с аргументами.  
  

## Использование функций

  
Напишем скрипт, содержащий объявление функции и использующий её:  
  

```bash
#!/bin/bash
function myfunc {
echo "This is an example of using a function"
}
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "This is the end of the loop"
myfunc
echo "End of the script"
```

  
Здесь создана функция с именем`myfunc`. Для вызова функции достаточно указать её имя.  
  

![](/images/a6961ed0295a812c7cc767030fe449ca.png)

  
_Результаты вызова функции_  
  
Функцию можно вызывать столько раз, сколько нужно. Обратите внимание на то, что попытавшись использовать функцию до её объявления, вы столкнётесь с ошибкой. Напишем демонстрирующий это скрипт:  
  

```bash
#!/bin/bash
count=1
while [ $count -le 3 ]
do
myfunc
count=$(( $count + 1 ))
done
echo "This is the end of the loop"
function myfunc {
echo "This is an example of using a function"
}
echo "End of the script"
```

  
Как и ожидается, ничего хорошего после его запуска не произошло.  
  

![](/images/81deab837f98ff07e863886c31df2e5f.png)

  
_Попытка воспользоваться функцией до её объявления_  
  
Придумывая имена для функций, учитывайте то, что они должны быть уникальными, иначе проблем не избежать. Если вы переопределите ранее объявленную функцию, новая функция будет вызываться вместо старой без каких-либо уведомлений или сообщений об ошибках. Продемонстрируем это на примере:  
  

```bash
#!/bin/bash
function myfunc {
echo "The first function definition"
}
myfunc
function myfunc {
echo "The second function definition"
}
myfunc
echo "End of the script"
```

  
Как видно, новая функция преспокойно затёрла старую.  
  

![](/images/7de8b1fbbff8a720b9d3ac669dcaccfc.png)

  
_Переопределение функции_  
  

## Использование команды return

  
Команда`return`позволяет задавать возвращаемый функцией целочисленный код завершения. Есть два способа работы с тем, что является результатом вызова функции. Вот первый:  
  

```bash
#!/bin/bash
function myfunc {
read -p "Enter a value: " value
echo "adding value"
return $(( $value + 10 ))
}
myfunc
echo "The new value is $?"
```

  
Команда`echo`вывела сумму введённого числа и числа 10.  
  

![](/images/afaa329ee155e253e462c95ec41b5f81.png)

  
_Вывод значения, возвращаемого функцией_  
  
Функция`myfunc`добавляет 10 к числу, которое содержится в переменной`$value`, значение которой задаёт пользователь во время работы сценария. Затем она возвращает результат, используя команду`return`. То, что возвратила функция, выводится командой`echo`с использованием переменной`$?`.  
Если вы выполните любую другую команду до извлечения из переменной`$?`значения, возвращённого функцией, это значение будет утеряно. Дело в том, что данная переменная хранит код возврата последней выполненной команды.  
  
Учтите, что максимальное число, которое может вернуть команда`return`— 255. Если функция должна возвращать большее число или строку, понадобится другой подход.  
  

## Запись вывода функции в переменную

  
Ещё один способ возврата результатов работы функции заключается в записи данных, выводимых функцией, в переменную. Такой подход позволяет обойти ограничения команды`return`и возвращать из функции любые данные. Рассмотрим пример:  
  

```bash
#!/bin/bash
function myfunc {
read -p "Enter a value: " value
echo $(( $value + 10 ))
}
result=$( myfunc)
echo "The value is $result"
```

  
Вот что получится после вызова данного скрипта.  
  

![](/images/70e84d7c95b8253fcde9a66ab19eb01b.png)

  
_Запись результатов работы функции в переменную_  
  

## Аргументы функций

  
Функции bash можно воспринимать как небольшие фрагменты кода, которые позволяют экономить время и место, избавляя нас от необходимости постоянно вводить с клавиатуры или копировать одни и те же наборы команд. Однако, возможности функций гораздо шире. В частности, речь идёт о передаче им аргументов.  
  
Функции могут использовать стандартные позиционные параметры, в которые записывается то, что передаётся им при вызове. Например, имя функции хранится в параметре`$0`, первый переданный ей аргумент — в`$1`, второй — в`$2`, и так далее. Количество переданных функции аргументов можно узнать, обратившись к переменной`$#`. Если вы знакомы с[третьей частью](https://habrahabr.ru/company/ruvds/blog/326328/)этого цикла материалов, вы не можете не заметить, что всё это очень похоже на то, как скрипты обрабатывают переданные им параметры командной строки.  
  
Аргументы передают функции, записывая их после её имени:  
  

```bash
myfunc $val1 10 20
```

  
Вот пример, в котором функция вызывается с аргументами и занимается их обработкой:  
  

```bash
#!/bin/bash
function addnum {
if [ $# -eq 0 ] || [ $# -gt 2 ]
then
echo -1
elif [ $# -eq 1 ]
then
echo $(( $1 + $1 ))
else
echo $(( $1 + $2 ))
fi
}
echo -n "Adding 10 and 15: "
value=$(addnum 10 15)
echo $value
echo -n "Adding one number: "
value=$(addnum 10)
echo $value
echo -n "Adding no numbers: "
value=$(addnum)
echo $value
echo -n "Adding three numbers: "
value=$(addnum 10 15 20)
echo $value
```

  
Запустим скрипт.  
  

![](/images/a44ee3accb8dc9a2d797de1aae892f64.png)

  
_Вызов функции с аргументами_  
  
Функция`addnum`проверяет число переданных ей при вызове из скрипта аргументов. Если их нет, или их больше двух, функция возвращает значение -1. Если параметр всего один, она прибавляет его к нему самому и возвращает результат. Если параметров два, функция складывает их.  
  
Обратите внимание на то, что функция не может напрямую работать с параметрами, которые переданы скрипту при его запуске из командной строки. Например, напишем такой сценарий:  
  

```bash
#!/bin/bash
function myfunc {
echo $(( $1 + $2 ))
}
if [ $# -eq 2 ]
then
value=$( myfunc)
echo "The result is $value"
else
echo "Usage: myfunc  a b"
fi
```

  
При его запуске, а точнее, при вызове объявленной в нём функции, будет выведено сообщение об ошибке.  
  

![](/images/68e3f352698961ee8915fef1c2f623c4.png)

  
_Функция не может напрямую использовать параметры, переданные сценарию_  
  
Вместо этого, если в функции планируется использовать параметры, переданные скрипту при вызове из командной строки, надо передать их ей при вызове:  
  

```bash
#!/bin/bash
function myfunc {
echo $(( $1 + $2 ))
}
if [ $# -eq 2 ]
then
value=$(myfunc $1 $2)
echo "The result is $value"
else
echo "Usage: myfunc a b"
fi
```

  
Теперь всё работает правильно.  
  

![](/images/6cdcbd4ebc0e4e2531b0a01cfecbb9e3.png)

  
_Передача функции параметров, с которыми запущен скрипт_  
  

## Работа с переменными в функциях

  
Переменные, которыми мы пользуемся в сценариях, характеризуются областью видимости. Это — те места кода, из которых можно работать с этими переменными. Переменные, объявленные внутри функций, ведут себя не так, как те переменные, с которыми мы уже сталкивались. Они могут быть скрыты от других частей скриптов.  
  
Существуют два вида переменных:  
  

*   Глобальные переменные.
*   Локальные переменные.

  

### Глобальные переменные

  
Глобальные переменные — это переменные, которые видны из любого места bash-скрипта. Если вы объявили глобальную переменную в основном коде скрипта, к такой переменной можно обратиться из функции.  
  
Почти то же самое справедливо и для глобальных переменных, объявленных в функциях. Обращаться к ним можно и в основном коде скрипта после вызова функций.  
  
По умолчанию все объявленные в скриптах переменные глобальны. Так, к переменным, объявленным за пределами функций, можно без проблем обращаться из функций:  
  

```bash
#!/bin/bash
function myfunc {
value=$(( $value + 10 ))
}
read -p "Enter a value: " value
myfunc
echo "The new value is: $value"
```

  
Вот что выведет этот сценарий.  
  

![](/images/b81e9e2e0af276ca5e8174cf94e4375f.png)

  
_Обращение к глобальной переменной из функции_  
  
Когда переменной присваивается новое значение в функции, это новое значение не теряется когда скрипт обращается к ней после завершения работы функции. Именно это можно видеть в предыдущем примере.  
  
Что если такое поведение нас не устраивает? Ответ прост — надо использовать локальные переменные.  
  

### Локальные переменные

  
Переменные, которые объявляют и используют внутри функции, могут быть объявлены локальными. Для того, чтобы это сделать, используется ключевое слово`local`перед именем переменной:  
  

```bash
local temp=$(( $value + 5 ))
```

  
Если за пределами функции есть переменная с таким же именем, это на неё не повлияет. Ключевое слово`local`позволяет отделить переменные, используемые внутри функции, от остальных переменных. Рассмотрим пример:  
  

```bash
#!/bin/bash
function myfunc {
local temp=$[ $value + 5 ]
echo "The Temp from inside function is $temp"
}
temp=4
myfunc
echo "The temp from outside is $temp"
```

  
Запустим скрипт.  
  

![](/images/74b9a7b17c8b03fd60e1177686229841.png)

  
_Локальная переменная в функции_  
  
Здесь, когда мы работаем с переменной`$temp`внутри функции, это не влияет на значение, назначенное переменной с таким же именем за её пределами.  
  

## Передача функциям массивов в качестве аргументов

  
Попробуем передать функции в качестве аргумента массив. Сразу хочется сказать, что работать такая конструкция будет неправильно:  
  

```bash
#!/bin/bash
function myfunc {
echo "The parameters are: $@"
arr=$1
echo "The received array is ${arr[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is: ${myarray[*]}"
myfunc $myarray
```

  

![](/images/a1ff181b8a0570c9d36c7813e8884773.png)

  
_Неправильный подход к передаче функциям массивов_  
  
Как видно из примера, при передаче функции массива, она получит доступ лишь к его первому элементу.  
  
Для того, чтобы эту проблему решить, из массива надо извлечь имеющиеся в нём данные и передать их функции как самостоятельные аргументы. Если надо, внутри функции полученные ей аргументы можно снова собрать в массив:  
  

```bash
#!/bin/bash
function myfunc {
local newarray
newarray=("$@")
echo "The new array value is: ${newarray[*]}"
}
myarray=(1 2 3 4 5)
echo "The original array is ${myarray[*]}"
myfunc ${myarray[*]}
```

  
Запустим сценарий.  
  

![](/images/f424e1d3f7d188c4753ec339a76ff360.png)

  
_Сборка массива внутри функции_  
  
Как видно из примера, функция собрала массив из переданных ей аргументов.  
  

## Рекурсивные функции

  
Рекурсия — это когда функция сама себя вызывает. Классический пример рекурсии — функция для вычисления факториала. Факториал числа — это произведение всех натуральных чисел от 1 до этого числа. Например, факториал 5 можно найти так:  
  

```
5! = 1 * 2 * 3 * 4 * 5
```

  
Если формулу вычисления факториала написать в рекурсивном виде, получится следующее:  
  

```
x! = x * (x-1)!
```

  
Этой формулой можно воспользоваться для того, чтобы написать рекурсивную функцию:  
  

```bash
#!/bin/bash
function factorial {
if [ $1 -eq 1 ]
then
echo 1
else
local temp=$(( $1 - 1 ))
local result=$(factorial $temp)
echo $(( $result * $1 ))
fi
}
read -p "Enter value: " value
result=$(factorial $value)
echo "The factorial of $value is: $result"
```

  
Проверим, верно ли работает этот скрипт.  
  

![](/images/941ac5d774ca48512ae25c2802414368.png)

  
_Вычисление факториала_  
  
Как видите, всё работает как надо.  
  

## Создание и использование библиотек

  
Итак, теперь вы знаете, как писать функции и как вызывать их в том же скрипте, где они объявлены. Что если надо использовать функцию, тот блок кода, который она собой представляет, в другом скрипте, не используя копирование и вставку?  
  
Оболочка bash позволяет создавать так называемые библиотеки — файлы, содержащие функции, а затем использовать эти библиотеки в любых скриптах, где они нужны.  
  
Ключ к использованию библиотек — в команде`source`. Эта команда используется для подключения библиотек к скриптам. В результате функции, объявленные в библиотеке, становятся доступными в скрипте, в противном же случае функции из библиотек не будут доступны в области видимости других скриптов.  
  
У команды`source`есть псевдоним — оператор «точка». Для того, чтобы подключить файл в скрипте, в скрипт надо добавить конструкцию такого вида:  
  

```
. ./myscript
```

  
Предположим, что у нас имеется файл`myfuncs`, который содержит следующее:  
  

```bash
function addnum {
echo $(( $1 + $2 ))
}
```

  
Это — библиотека. Воспользуемся ей в сценарии:  
  

```bash
#!/bin/bash
. ./myfuncs
result=$(addnum 10 20)
echo "The result is: $result"
```

  
Вызовем его.  
  

![](/images/8dada91fc5635e589800ca9e4363a460.png)

  
_Использование библиотек_  
  
Только что мы использовали библиотечную функцию внутри скрипта. Всё это замечательно, но что если мы хотим вызвать функцию, объявленную в библиотеке, из командной строки?  
  

## Вызов bash-функций из командной строки

  
Если вы освоили[предыдущую часть](https://habrahabr.ru/company/ruvds/blog/326826/)из этой серии, вы, вероятно, уже догадываетесь, что функцию из библиотеки можно подключить в файле .`bashrc`, используя команду`source`. Как результат, вызывать функцию можно будет прямо из командной строки.  
  
Отредактируйте`.bashrc`, добавив в него такую строку (путь к файлу библиотеки в вашей системе, естественно, будет другим):  
  

```
. /home/likegeeks/Desktop/myfuncs
```

  
Теперь функцию можно вызывать прямо из командной строки:  
  

```console
$ addnum 10 20
```

  

![](/images/5ef59294384dfd3fe9e1188a2ceda324.png)

  
_Вызов функции из командной строки_  
  
Ещё приятнее то, что такая вот библиотека оказывается доступной всем дочерним процессам оболочки, то есть — ей можно пользоваться в bash-скриптах, не заботясь о подключении к ним этой библиотеки.  
  
Тут стоит отметить, что для того, чтобы вышеприведённый пример заработал, может понадобиться выйти из системы, а потом войти снова. Кроме того, обратите внимание на то, что если имя функции из библиотеки совпадёт с именем какой-нибудь стандартной команды, вместо этой команды будет вызываться функция. Поэтому внимательно относитесь к именам функций.


# Bash-скрипты, часть 7: sed и обработка текстов

## Основы работы с sed

  
Утилиту sed называют потоковым текстовым редактором. В интерактивных текстовых редакторах, наподобие nano, с текстами работают, используя клавиатуру, редактируя файлы, добавляя, удаляя или изменяя тексты. Sed позволяет редактировать потоки данных, основываясь на заданных разработчиком наборах правил. Вот как выглядит схема вызова этой команды:  
  

```
$ sed options file
```

  
По умолчанию sed применяет указанные при вызове правила, выраженные в виде набора команд, к`STDIN`. Это позволяет передавать данные непосредственно sed.  
  
Например, так:  
  

```
$ echo "This is a test" | sed 's/test/another test/'
```

  
Вот что получится при выполнении этой команды.  
  

![](/images/0034002d055addd8a4856665f77b4339.png)

  
_Простой пример вызова sed_  
  
В данном случае sed заменяет слово «test» в строке, переданной для обработки, словами «another test». Для оформления правила обработки текста, заключённого в кавычки, используются прямые слэши. В нашем случае применена команда вида`s/pattern1/pattern2/`. Буква «s» — это сокращение слова «substitute», то есть — перед нами команда замены. Sed, выполняя эту команду, просмотрит переданный текст и заменит найденные в нём фрагменты (о том — какие именно, поговорим ниже), соответствующие`pattern1`, на`pattern2`.  
  
Выше приведён примитивный пример использования sed, нужный для того, чтобы ввести вас в курс дела. На самом деле, sed можно применять в гораздо более сложных сценариях обработки текстов, например — для работы с файлами.  
  
Ниже показан файл, в котором содержится фрагмент текста, и результаты его обработки такой командой:  
  

```
$ sed 's/test/another test' ./myfile
```

  

![](/images/f182713713c516cf7dd12b56d8579c98.png)

  
_Текстовый файл и результаты его обработки_  
  
Здесь применён тот же подход, который мы использовали выше, но теперь sed обрабатывает текст, хранящийся в файле. При этом, если файл достаточно велик, можно заметить, что sed обрабатывает данные порциями и выводит то, что обработано, на экран, не дожидаясь обработки всего файла.  
  
Sed не меняет данные в обрабатываемом файле. Редактор читает файл, обрабатывает прочитанное, и отправляет то, что получилось, в`STDOUT`. Для того, чтобы убедиться в том, что исходный файл не изменился, достаточно, после того, как он был передан sed, открыть его. При необходимости вывод sed можно перенаправить в файл, возможно — перезаписать старый файл. Если вы знакомы с одним из предыдущих[материалов](https://habrahabr.ru/company/ruvds/blog/326594/)этой серии, где речь идёт о перенаправлении потоков ввода и вывода, вы вполне сможете это сделать.  
  

## Выполнение наборов команд при вызове sed

  
Для выполнения нескольких действий с данными, используйте ключ`-e`при вызове sed. Например, вот как организовать замену двух фрагментов текста:  
  

```
$ sed -e 's/This/That/; s/test/another test/' ./myfile
```

  

![](/images/abdbac90d073f056788d64f50983f8a6.png)

  
_Использование ключа -e при вызове sed_  
  
К каждой строке текста из файла применяются обе команды. Их нужно разделить точкой с запятой, при этом между окончанием команды и точкой с запятой не должно быть пробела.  
Для ввода нескольких шаблонов обработки текста при вызове sed, можно, после ввода первой одиночной кавычки, нажать Enter, после чего вводить каждое правило с новой строки, не забыв о закрывающей кавычке:  
  

```
$ sed -e '
> s/This/That/
> s/test/another test/' ./myfile
```

  
Вот что получится после того, как команда, представленная в таком виде, будет выполнена.  
  

![](/images/3c8820a20ba2110e8564fd0c842c69a1.png)

  
_Другой способ работы с sed_  
  

## Чтение команд из файла

  
Если имеется множество команд sed, с помощью которых надо обработать текст, обычно удобнее всего предварительно записать их в файл. Для того, чтобы указать sed файл, содержащий команды, используют ключ`-f`:  
  
Вот содержимое файла`mycommands`:  
  

```
s/This/That/
s/test/another test/
```

  
Вызовем sed, передав редактору файл с командами и файл для обработки:  
  

```
$ sed -f mycommands myfile
```

  
Результат при вызове такой команды аналогичен тому, который получался в предыдущих примерах.  
  

![](/images/798725466a87616ce1a839d839b2ee4f.png)

  
_Использование файла с командами при вызове sed_  
  

## Флаги команды замены

  
Внимательно посмотрите на следующий пример.  
  

```
$ sed 's/test/another test/' myfile
```

  
Вот что содержится в файле, и что будет получено после его обработки sed.  
  

![](/images/2b223bbcf88ab80c8e9c41eec40f941b.png)

  
_Исходный файл и результаты его обработки_  
  
Команда замены нормально обрабатывает файл, состоящий из нескольких строк, но заменяются только первые вхождения искомого фрагмента текста в каждой строке. Для того, чтобы заменить все вхождения шаблона, нужно использовать соответствующий флаг.  
  
Схема записи команды замены при использовании флагов выглядит так:  
  

```
s/pattern/replacement/flags
```

  
Выполнение этой команды можно модифицировать несколькими способами.  
  

*   При передаче номера учитывается порядковый номер вхождения шаблона в строку, заменено будет именно это вхождение.  
    
*   Флаг`g`указывает на то, что нужно обработать все вхождения шаблона, имеющиеся в строке.  
    
*   Флаг`p`указывает на то, что нужно вывести содержимое исходной строки.  
    
*   Флаг вида`w file`указывает команде на то, что нужно записать результаты обработки текста в файл.  
    

  
Рассмотрим использование первого варианта команды замены, с указанием позиции заменяемого вхождения искомого фрагмента:  
  

```
$ sed 's/test/another test/2' myfile
```

  

![](/images/a54fe87f0fc9b8d27b06f63567f226c6.png)

  
_Вызов команды замены с указанием позиции заменяемого фрагмента_  
  
Тут мы указали, в качестве флага замены, число 2. Это привело к тому, что было заменено лишь второе вхождение искомого шаблона в каждой строке. Теперь опробуем флаг глобальной замены —`g`:  
  

```
$ sed 's/test/another test/g' myfile
```

  
Как видно из результатов вывода, такая команда заменила все вхождения шаблона в тексте.  
  

![](/images/b9e655342c3c79d46451f3f6009e4112.png)

  
_Глобальная замена_  
  
Флаг команды замены`p`позволяет выводить строки, в которых найдены совпадения, при этом ключ`-n`, указанный при вызове sed, подавляет обычный вывод:  
  

```
$ sed -n 's/test/another test/p' myfile
```

  
Как результат, при запуске sed в такой конфигурации на экран выводятся лишь строки (в нашем случае — одна строка), в которых найден заданный фрагмент текста.  
  

![](/images/4af7e88bb859d3ec2d13c8930dcbeb0a.png)

  
_Использование флага команды замены p_  
  
Воспользуемся флагом`w`, который позволяет сохранить результаты обработки текста в файл:  
  

```
$ sed 's/test/another test/w output' myfile
```

  

![](/images/b6595daff5c4d194dd9dc1788a275d22.png)

  
_Сохранение результатов обработки текста в файл_  
  
Хорошо видно, что в ходе работы команды данные выводятся в[STDOUT](https://habrahabr.ru/company/ruvds/blog/326594/), при этом обработанные строки записываются в файл, имя которого указано после`w`.  
  

## Символы-разделители

  
Представьте, что нужно заменить`/bin/bash`на`/bin/csh`в файле`/etc/passwd`. Задача не такая уж и сложная:  
  

```
$ sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd
```

  
Однако, выглядит всё это не очень-то хорошо. Всё дело в том, что так как прямые слэши используются в роли символов-разделителей, такие же символы в передаваемых sed строках приходится экранировать. В результате страдает читаемость команды.  
  
К счастью, sed позволяет нам самостоятельно задавать символы-разделители для использования их в команде замены. Разделителем считается первый символ, который будет встречен после`s`:  
  

```
$ sed 's!/bin/bash!/bin/csh!' /etc/passwd
```

  
В данном случае в качестве разделителя использован восклицательный знак, в результате код легче читать и он выглядит куда опрятнее, чем прежде.  
  

## Выбор фрагментов текста для обработки

  
До сих пор мы вызывали sed для обработки всего переданного редактору потока данных. В некоторых случаях с помощью sed надо обработать лишь какую-то часть текста — некую конкретную строку или группу строк. Для достижения такой цели можно воспользоваться двумя подходами:  
  

*   Задать ограничение на номера обрабатываемых строк.  
    
*   Указать фильтр, соответствующие которому строки нужно обработать.  
    

  
Рассмотрим первый подход. Тут допустимо два варианта. Первый, рассмотренный ниже, предусматривает указание номера одной строки, которую нужно обработать:  
  

```
$ sed '2s/test/another test/' myfile
```

  

![](/images/de2bc0f0ff9ed238085298bdde0e0b5e.png)

  
_Обработка только одной строки, номер который задан при вызове sed_  
  
Второй вариант — диапазон строк:  
  

```
$ sed '2,3s/test/another test/' myfile
```

  

![](/images/782882bed5d8f69312c9ba035fb84f2b.png)

  
_Обработка диапазона строк_  
  
Кроме того, можно вызвать команду замены так, чтобы файл был обработан начиная с некоей строки и до конца:  
  

```
$ sed '2,$s/test/another test/' myfile
```

  

![](/images/64b51fad408d00d803f80fc8c6ec7859.png)

  
_Обработка файла начиная со второй строки и до конца_  
  
Для того, чтобы обрабатывать с помощью команды замены только строки, соответствующие заданному фильтру, команду надо вызвать так:  
  

```
$ sed '/likegeeks/s/bash/csh/' /etc/passwd
```

  
По аналогии с тем, что было рассмотрено выше, шаблон передаётся перед именем команды`s`.  
  

![](/images/51f53115d810706487f9affff1281994.png)

  
_Обработка строк, соответствующих фильтру_  
  
Тут мы использовали очень простой фильтр. Для того, чтобы в полной мере раскрыть возможности данного подхода, можно воспользоваться регулярными выражениями. О них мы поговорим в одном из следующих материалов этой серии.  
  

## Удаление строк

  
Утилита sed годится не только для замены одних последовательностей символов в строках на другие. С её помощью, а именно, используя команду`d`, можно удалять строки из текстового потока.  
  
Вызов команды выглядит так:  
  

```
$ sed '3d' myfile
```

  
Мы хотим, чтобы из текста была удалена третья строка. Обратите внимание на то, что речь не идёт о файле. Файл останется неизменным, удаление отразится лишь на выводе, который сформирует sed.  
  

![](/images/05ad703f73023686c4c9ae7dad126252.png)

  
_Удаление третьей строки_  
  
Если при вызове команды`d`не указать номер удаляемой строки, удалены будут все строки потока.  
  
Вот как применить команду`d`к диапазону строк:  
  

```
$ sed '2,3d' myfile
```

  

![](/images/0a58ab5be14c11121d761c7e8973dd1d.png)

  
_Удаление диапазона строк_  
  
А вот как удалить строки, начиная с заданной — и до конца файла:  
  

```
$ sed '3,$d' myfile
```

  

![](/images/48ce22f12b835645a7b53e138d5591c8.png)

  
_Удаление строк до конца файла_  
  
Строки можно удалять и по шаблону:  
  

```
$ sed '/test/d' myfile
```

  

![](/images/e7eed5e18cac4a22642ed4fce029615d.png)

  
_Удаление строк по шаблону_  
  
При вызове`d`можно указывать пару шаблонов — будут удалены строки, в которых встретится шаблон, и те строки, которые находятся между ними:  
  

```
$ sed '/second/,/fourth/d' myfile
```

  

![](/images/7063df7b072328aa6c32bc4701c13a2a.png)

  
_Удаление диапазона строк с использованием шаблонов_  
  

## Вставка текста в поток

  
С помощью sed можно вставлять данные в текстовый поток, используя команды `i` и `a`:  
  

*   Команда `i` добавляет новую строку перед заданной.  
    
*   Команда `a` добавляет новую строку после заданной.  
    

  
Рассмотрим пример использования команды`i`:  
  

```
$ echo "Another test" | sed 'i\First test '
```

  

![](/images/be96cd803c49925b9516b989f902b3de.png)

  
_Команда i_  
  
Теперь взглянем на команду`a`:  
  

```
$ echo "Another test" | sed 'a\First test '
```

  

![](/images/10d8b8b4f5a0ce85030f0e5563db8127.png)

  
_Команда a_  
  
Как видно, эти команды добавляют текст до или после данных из потока. Что если надо добавить строку где-нибудь посередине?  
  
Тут нам поможет указание номера опорной строки в потоке, или шаблона. Учтите, что адресация строк в виде диапазона тут не подойдёт. Вызовем команду`i`, указав номер строки, перед которой надо вставить новую строку:  
  

```
$ sed '2i\This is the inserted line.' myfile
```

  
  

![](/images/0946be4ef914bf39059fd01eb97bd948.png)

  
_Команда i с указанием номера опорной строки_  
  
Проделаем то же самое с командой`a`:  
  

```
$ sed '2a\This is the appended line.' myfile
```

  

![](/images/b800d3eb18a27f331d8fc9b5b3f014c2.png)

  
_Команда a с указанием номера опорной строки_  
  
Обратите внимание на разницу в работе команд`i`и`a`. Первая вставляет новую строку до указанной, вторая — после.  
  

## Замена строк

  
Команда`c`позволяет изменить содержимое целой строки текста в потоке данных. При её вызове нужно указать номер строки, вместо которой в поток надо добавить новые данные:  
  

```
$ sed '3c\This is a modified line.' myfile
```

  

![](/images/46388b3e27486dc3ec57e7286529563c.png)

  
_Замена строки целиком_  
  
Если воспользоваться при вызове команды шаблоном в виде обычного текста или регулярного выражения, заменены будут все соответствующие шаблону строки:  
  

```
$ sed '/This is/c This is a changed line of text.' myfile
```

  

![](/images/3e9f61112ede9cd01bc9258449a2bb76.png)

  
_Замена строк по шаблону_  
  

## Замена символов

  
Команда`y`работает с отдельными символами, заменяя их в соответствии с переданными ей при вызове данными:  
  

```
$ sed 'y/123/567/' myfile
```

  

![](/images/08f6e3fff71b4d8ff29eeb861f45f87e.png)

  
_Замена символов_  
  
Используя эту команду, нужно учесть, что она применяется ко всему текстовому потоку, ограничить её конкретными вхождениями символов нельзя.  
  

## Вывод номеров строк

  
Если вызвать sed, использовав команду`=`, утилита выведет номера строк в потоке данных:  
  

```
$ sed '=' myfile
```

  

![](/images/8cf93dc7dbfff532d258cf84f92dd990.png)

  
_Вывод номеров строк_  
  
Потоковый редактор вывел номера строк перед их содержимым.  
  
Если передать этой команде шаблон и воспользоваться ключом sed`-n`, выведены будут только номера строк, соответствующих шаблону:  
  

```
$ sed -n '/test/=' myfile
```

  

![](/images/cba74750fb26c13f9c91d5ebaa14c3bb.png)

  
_Вывод номеров строк, соответствующих шаблону_  
  

## Чтение данных для вставки из файла

  
Выше мы рассматривали приёмы вставки данных в поток, указывая то, что надо вставить, прямо при вызове sed. В качестве источника данных можно воспользоваться и файлом. Для этого служит команда`r`, которая позволяет вставлять в поток данные из указанного файла. При её вызове можно указать номер строки, после которой надо вставить содержимое файла, или шаблон.  
  
Рассмотрим пример:  
  

```
$ sed '3r newfile' myfile
```

  
  

![](/images/c79cbf3adeabd2b1fd103ce59a8d27fe.png)

  
_Вставка в поток содержимого файла_  
  
Тут содержимое файла`newfile`было вставлено после третьей строки файла`myfile`.  
  
Вот что произойдёт, если применить при вызове команды`r`шаблон:  
  

```
$ sed '/test/r newfile' myfile
```

  

![](/images/cbdbb8b9db2f43d1f468db24ccf0647e.png)

  
_Использование шаблона при вызове команды r_  
  
Содержимое файла будет вставлено после каждой строки, соответствующей шаблону.  
  

## Пример

  
Представим себе такую задачу. Есть файл, в котором имеется некая последовательность символов, сама по себе бессмысленная, которую надо заменить на данные, взятые из другого файла. А именно, пусть это будет файл`newfile`, в котором роль указателя места заполнения играет последовательность символов`DATA`. Данные, которые нужно подставить вместо`DATA`, хранятся в файле`data`.  
  
Решить эту задачу можно, воспользовавшись командами`r`и`d`потокового редактора sed:  
  

```
$ Sed '/DATA>/ {
r newfile
d}' myfile
```

  

![](/images/5ac3624e55a40dad7ac8d542f35eb934.png)

  
_Замена указателя места заполнения на реальные данные_  
  
Как видите, вместо заполнителя`DATA`sed добавил в выходной поток две строки из файла`data`.

# Bash-скрипты, часть 8: язык обработки данных awk

## Особенности вызова awk

  
Схема вызова awk выглядит так:  
  

```
$ awk options program file
```

  
Awk воспринимает поступающие к нему данные в виде набора записей. Записи представляют собой наборы полей. Упрощенно, если не учитывать возможности настройки awk и говорить о некоем вполне обычном тексте, строки которого разделены символами перевода строки, запись — это строка. Поле — это слово в строке.  
  
Рассмотрим наиболее часто используемые ключи командной строки awk:  
  

> `-F fs` — позволяет указать символ-разделитель для полей в записи.  
> `-f file` — указывает имя файла, из которого нужно прочесть awk-скрипт.  
> `-v var=value` — позволяет объявить переменную и задать её значение по умолчанию, которое будет использовать awk.  
> `-mf N` — задаёт максимальное число полей для обработки в файле данных.  
> `-mr N` — задаёт максимальный размер записи в файле данных.  
> `-W keyword` — позволяет задать режим совместимости или уровень выдачи предупреждений awk.

  
Настоящая мощь awk скрывается в той части команды его вызова, которая помечена выше как`program`. Она указывает на файл awk-скрипта, написанный программистом и предназначенный для чтения данных, их обработки и вывода результатов.  
  

## Чтение awk-скриптов из командной строки

  
Скрипты awk, которые можно писать прямо в командной строке, оформляются в виде текстов команд, заключённых в фигурные скобки. Кроме того, так как awk предполагает, что скрипт представляет собой текстовую строку, его нужно заключить в одинарные кавычки:  
  

```
$ awk '{print "Welcome to awk command tutorial"}'
```

  
Запустим эту команду… И ничего не произойдёт Дело тут в том, что мы, при вызове awk, не указали файл с данными. В подобной ситуации awk ожидает поступления данных из[STDIN](https://habrahabr.ru/company/ruvds/blog/326594/). Поэтому выполнение такой команды не приводит к немедленно наблюдаемым эффектам, но это не значит, что awk не работает — он ждёт входных данных из`STDIN`.  
  
Если теперь ввести что-нибудь в консоль и нажать`Enter`, awk обработает введённые данные с помощью скрипта, заданного при его запуске. Awk обрабатывает текст из потока ввода построчно, этим он похож на sed. В нашем случае awk ничего не делает с данными, он лишь, в ответ на каждую новую полученную им строку, выводит на экран текст, заданный в команде`print`.  
  

![](/images/5a19a94cad5893fc2194fb599cad5422.png)

  
_Первый запуск awk, вывод на экран заданного текста_  
  
Что бы мы ни ввели, результат в данном случае будет одним и тем же — вывод текста.  
Для того, чтобы завершить работу awk, нужно передать ему символ конца файла (EOF, End-of-File). Сделать это можно, воспользовавшись сочетанием клавиш`CTRL + D`.  
  
Неудивительно, если этот первый пример показался вам не особо впечатляющим. Однако, самое интересное — впереди.  
  

## Позиционные переменные, хранящие данные полей

  
Одна из основных функций awk заключается в возможности манипулировать данными в текстовых файлах. Делается это путём автоматического назначения переменной каждому элементу в строке. По умолчанию awk назначает следующие переменные каждому полю данных, обнаруженному им в записи:  
  

*   `$0` — представляет всю строку текста (запись).
*   `$1` — первое поле.
*   `$2` — второе поле.
*   `$n` — n-ное поле.

  
Поля выделяются из текста с использованием символа-разделителя. По умолчанию — это пробельные символы вроде пробела или символа табуляции.  
  
Рассмотрим использование этих переменных на простом примере. А именно, обработаем файл, в котором содержится несколько строк (этот файл показан на рисунке ниже) с помощью такой команды:  
  

```
$ awk '{print $1}' myfile
```

  

![](/images/cf0b80d4a6ddb34d0b2f15c7ea54557a.png)

  
_Вывод в консоль первого поля каждой строки_  
  
Здесь использована переменная`$1`, которая позволяет получить доступ к первому полю каждой строки и вывести его на экран.  
  
Иногда в некоторых файлах в качестве разделителей полей используется что-то, отличающееся от пробелов или символов табуляции. Выше мы упоминали ключ awk`-F`, который позволяет задать необходимый для обработки конкретного файла разделитель:  
  

```
$ awk -F: '{print $1}' /etc/passwd
```

  

![](/images/2bf8033b122fdf3960311ebb80a67779.png)

  
_Указание символа-разделителя при вызове awk_  
  
Эта команда выводит первые элементы строк, содержащихся в файле`/etc/passwd`. Так как в этом файле в качестве разделителей используются двоеточия, именно этот символ был передан awk после ключа`-F`.  
  

## Использование нескольких команд

  
Вызов awk с одной командой обработки текста — подход очень ограниченный. Awk позволяет обрабатывать данные с использованием многострочных скриптов. Для того, чтобы передать awk многострочную команду при вызове его из консоли, нужно разделить её части точкой с запятой:  
  

```
$ echo "My name is Tom" | awk '{$4="Adam"; print $0}'
```

  

![](/images/a8c5b92921519f181cd5b2383956ffcb.png)

  
_Вызов awk из командной строки с передачей ему многострочного скрипта_  
  
В данном примере первая команда записывает новое значение в переменную`$4`, а вторая выводит на экран всю строку.  
  

## Чтение скрипта awk из файла

  
Awk позволяет хранить скрипты в файлах и ссылаться на них, используя ключ`-f`. Подготовим файл`testfile`, в который запишем следующее:  
  

```
{print $1 " has a  home directory at " $6}
```

  
Вызовем awk, указав этот файл в качестве источника команд:  
  

```
$ awk -F: -f testfile /etc/passwd
```

  

![](/images/b0b532a2f0c6597bb533bda90c747217.png)

  
_Вызов awk с указанием файла скрипта_  
  
Тут мы выводим из файла`/etc/passwd`имена пользователей, которые попадают в переменную`$1`, и их домашние директории, которые попадают в`$6`. Обратите внимание на то, что файл скрипта задают с помощью ключа`-f`, а разделитель полей, двоеточие в нашем случае, с помощью ключа`-F`.  
  
В файле скрипта может содержаться множество команд, при этом каждую из них достаточно записывать с новой строки, ставить после каждой точку с запятой не требуется.  
Вот как это может выглядеть:  
  

```
{
text = " has a  home directory at "
print $1 text $6
}
```

  
Тут мы храним текст, используемый при выводе данных, полученных из каждой строки обрабатываемого файла, в переменной, и используем эту переменную в команде`print`. Если воспроизвести предыдущий пример, записав этот код в файл`testfile`, выведено будет то же самое.  
  

## Выполнение команд до начала обработки данных

  
Иногда нужно выполнить какие-то действия до того, как скрипт начнёт обработку записей из входного потока. Например — создать шапку отчёта или что-то подобное.  
  
Для этого можно воспользоваться ключевым словом`BEGIN`. Команды, которые следуют за`BEGIN`, будут исполнены до начала обработки данных. В простейшем виде это выглядит так:  
  

```
$ awk 'BEGIN {print "Hello World!"}'
```

  
А вот — немного более сложный пример:  
  

```
$ awk 'BEGIN {print "The File Contents:"}
{print $0}' myfile
```

  

![](/images/c50282673675bee9a49dfd9b6dfe32ea.png)

  
_Выполнение команд до начала обработки данных_  
  
Сначала awk исполняет блок`BEGIN`, после чего выполняется обработка данных. Будьте внимательны с одинарными кавычками, используя подобные конструкции в командной строке. Обратите внимание на то, что и блок`BEGIN`, и команды обработки потока, являются в представлении awk одной строкой. Первая одинарная кавычка, ограничивающая эту строку, стоит перед`BEGIN`. Вторая — после закрывающей фигурной скобки команды обработки данных.  
  

## Выполнение команд после окончания обработки данных

  
Ключевое слово`END`позволяет задавать команды, которые надо выполнить после окончания обработки данных:  
  

```
$ awk 'BEGIN {print "The File Contents:"}
{print $0}
END {print "End of File"}' myfile
```

  

![](/images/a32206c12e4c7628696cb62aed26b775.png)

  
_Результаты работы скрипта, в котором имеются блоки BEGIN и END_  
  
После завершения вывода содержимого файла, awk выполняет команды блока`END`. Это полезная возможность, с её помощью, например, можно сформировать подвал отчёта. Теперь напишем скрипт следующего содержания и сохраним его в файле`myscript`:  
  

```
BEGIN {
print "The latest list of users and shells"
print " UserName \t HomePath"
print "-------- \t -------"
FS=":"
}
{
print $1 " \t " $6
}
END {
print "The end"
}
```

  
Тут, в блоке`BEGIN`, создаётся заголовок табличного отчёта. В этом же разделе мы указываем символ-разделитель. После окончания обработки файла, благодаря блоку`END`, система сообщит нам о том, что работа окончена.  
  
Запустим скрипт:  
  

```
$ awk -f myscript  /etc/passwd
```

  

![](/images/1090704fb0f7853ce09f4fdc7d813c9d.png)

  
_Обработка файла /etc/passwd с помощью awk-скрипта_  
  
Всё, о чём мы говорили выше — лишь малая часть возможностей awk. Продолжим освоение этого полезного инструмента.  
  

## Встроенные переменные: настройка процесса обработки данных

  
Утилита awk использует встроенные переменные, которые позволяют настраивать процесс обработки данных и дают доступ как к обрабатываемым данным, так и к некоторым сведениям о них.  
  
Мы уже рассматривали позиционные переменные —`$1`,`$2`,`$3`, которые позволяют извлекать значения полей, работали мы и с некоторыми другими переменными. На самом деле, их довольно много. Вот некоторые из наиболее часто используемых:  

> `FIELDWIDTHS —`разделённый пробелами список чисел, определяющий точную ширину каждого поля данных с учётом разделителей полей.  
> `FS`— уже знакомая вам переменная, позволяющая задавать символ-разделитель полей.  
> `RS —`переменная, которая позволяет задавать символ-разделитель записей.  
> `OFS —`разделитель полей на выводе awk-скрипта.  
> `ORS —`разделитель записей на выводе awk-скрипта.

  
По умолчанию переменная`OFS`настроена на использование пробела. Её можно установить так, как нужно для целей вывода данных:  
  

```
$ awk 'BEGIN{FS=":"; OFS="-"} {print $1,$6,$7}' /etc/passwd
```

  

![](/images/a92f855d88053f7a0538abc1c3b57600.png)

  
_Установка разделителя полей выходного потока_  
  
Переменная`FIELDWIDTHS`позволяет читать записи без использования символа-разделителя полей.  
  
В некоторых случаях, вместо использования разделителя полей, данные в пределах записей расположены в колонках постоянной ширины. В подобных случаях необходимо задать переменную`FIELDWIDTHS`таким образом, чтобы её содержимое соответствовало особенностям представления данных.  
  
При установленной переменной`FIELDWIDTHS`awk будет игнорировать переменную`FS`и находить поля данных в соответствии со сведениями об их ширине, заданными в`FIELDWIDTHS`.  
  
Предположим, имеется файл`testfile`, содержащий такие данные:  
  

```
1235.9652147.91
927-8.365217.27
36257.8157492.5
```

  
Известно, что внутренняя организация этих данных соответствует шаблону 3-5-2-5, то есть, первое поле имеет ширину 3 символа, второе — 5, и так далее. Вот скрипт, который позволит разобрать такие записи:  
  

```
$ awk 'BEGIN{FIELDWIDTHS="3 5 2 5"}{print $1,$2,$3,$4}' testfile
```

  

![](/images/b9b46c4ae70cc3c2cb2db7107dcdf48e.png)

  
_Использование переменной FIELDWIDTHS_  
  
Посмотрим на то, что выведет скрипт. Данные разобраны с учётом значения переменной`FIELDWIDTHS`, в результате числа и другие символы в строках разбиты в соответствии с заданной шириной полей.  
  
Переменные`RS`и`ORS`задают порядок обработки записей. По умолчанию`RS`и`ORS`установлены на символ перевода строки. Это означает, что awk воспринимает каждую новую строку текста как новую запись и выводит каждую запись с новой строки.  
  
Иногда случается так, что поля в потоке данных распределены по нескольким строкам. Например, пусть имеется такой файл с именем`addresses`:  
  

```
Person Name
123 High Street
(222) 466-1234

Another person
487 High Street
(523) 643-8754
```

  
Если попытаться прочесть эти данные при условии, что`FS`и`RS`установлены в значения по умолчанию, awk сочтёт каждую новую строку отдельной записью и выделит поля, опираясь на пробелы. Это не то, что нам в данном случае нужно.  
  
Для того, чтобы решить эту проблему, в`FS`надо записать символ перевода строки. Это укажет awk на то, что каждая строка в потоке данных является отдельным полем.  
  
Кроме того, в данном примере понадобится записать в переменную`RS`пустую строку. Обратите внимание на то, что в файле блоки данных о разных людях разделены пустой строкой. В результате awk будет считать пустые строки разделителями записей. Вот как всё это сделать:  
  

```
$ awk 'BEGIN{FS="\n"; RS=""} {print $1,$3}' addresses
```

  

![](/images/5f03e528de8e4355a16769871035e46d.png)

  
_Результаты настройки переменных RS и FS_  
  
Как видите, awk, благодаря таким настройкам переменных, воспринимает строки из файла как поля, а разделителями записей становятся пустые строки.  
  

## Встроенные переменные: сведения о данных и об окружении

  
Помимо встроенных переменных, о которых мы уже говорили, существуют и другие, которые предоставляют сведения о данных и об окружении, в котором работает awk:  

> `ARGC`— количество аргументов командной строки.  
> `ARGV`— массив с аргументами командной строки.  
> `ARGIND`— индекс текущего обрабатываемого файла в массиве`ARGV`.  
> `ENVIRON`— ассоциативный массив с переменными окружения и их значениями.  
> `ERRNO`— код системной ошибки, которая может возникнуть при чтении или закрытии входных файлов.  
> `FILENAME`— имя входного файла с данными.  
> `FNR`— номер текущей записи в файле данных.  
> `IGNORECASE`— если эта переменная установлена в ненулевое значение, при обработке игнорируется регистр символов.  
> `NF`— общее число полей данных в текущей записи.  
> `NR`— общее число обработанных записей.

  
Переменные`ARGC`и`ARGV`позволяют работать с аргументами командной строки. При этом скрипт, переданный awk, не попадает в массив аргументов`ARGV`. Напишем такой скрипт:  
  

```
$ awk 'BEGIN{print ARGC,ARGV[1]}' myfile
```

  
После его запуска можно узнать, что общее число аргументов командной строки — 2, а под индексом 1 в массиве`ARGV`записано имя обрабатываемого файла. В элементе массива с индексом 0 в данном случае будет «awk».  
  

![](/images/2e815abfd2b87f1a83cbebddba6d4d19.png)

  
_Работа с параметрами командной строки_  
  
Переменная`ENVIRON`представляет собой ассоциативный массив с переменными среды. Опробуем её:  
  

```
$ awk '
BEGIN{
print ENVIRON["HOME"]
print ENVIRON["PATH"]
}'
```

  

![](/images/94ae22cacf533cf05ce5a8c6cbb0d816.png)

  
_Работа с переменными среды_  
  
Переменные среды можно использовать и без обращения к`ENVIRON`. Сделать это, например, можно так:  
  

```
$  echo | awk -v home=$HOME '{print "My home is " home}'
```

  

![](/images/50cb5580ee7438efd090b326d5af3a15.png)

  
_Работа с переменными среды без использования ENVIRON_  
  
Переменная`NF`позволяет обращаться к последнему полю данных в записи, не зная его точной позиции:  
  

```
$ awk 'BEGIN{FS=":"; OFS=":"} {print $1,$NF}' /etc/passwd
```

  

![](/images/619da6d74f1e59ed5c94800d58b817f2.png)

  
_Пример использования переменной NF_  
  
Эта переменная содержит числовой индекс последнего поля данных в записи. Обратиться к данному полю можно, поместив перед`NF`знак`$`.  
  
Переменные`FNR`и`NR`, хотя и могут показаться похожими, на самом деле различаются. Так, переменная`FNR`хранит число записей, обработанных в текущем файле. Переменная`NR`хранит общее число обработанных записей. Рассмотрим пару примеров, передав awk один и тот же файл дважды:  
  

```
$ awk 'BEGIN{FS=","}{print $1,"FNR="FNR}' myfile myfile
```

  

![](/images/2450b252839c00764accd771336fe518.png)

  
_Исследование переменной FNR_  
  
Передача одного и того же файла дважды равносильна передаче двух разных файлов. Обратите внимание на то, что`FNR`сбрасывается в начале обработки каждого файла.  
  
Взглянем теперь на то, как ведёт себя в подобной ситуации переменная`NR`:  
  

```
$ awk '
BEGIN {FS=","}
{print $1,"FNR="FNR,"NR="NR}
END{print "There were",NR,"records processed"}' myfile myfile
```

  

![](/images/9814bd85ce8fc22a2299f3ce35cd813e.png)

  
_Различие переменных NR и FNR_  
  
Как видно,`FNR`, как и в предыдущем примере, сбрасывается в начале обработки каждого файла, а вот`NR`, при переходе к следующему файлу, сохраняет значение.  
  

## Пользовательские переменные

  
Как и любые другие языки программирования, awk позволяет программисту объявлять переменные. Имена переменных могут включать в себя буквы, цифры, символы подчёркивания. Однако, они не могут начинаться с цифры. Объявить переменную, присвоить ей значение и воспользоваться ей в коде можно так:  
  

```
$ awk '
BEGIN{
test="This is a test"
print test
}'
```

  

![](/images/71150395079a584116811d6635023259.png)

  
_Работа с пользовательской переменной_  
  

## Условный оператор

  
Awk поддерживает стандартный во многих языках программирования формат условного оператора`if-then-else`. Однострочный вариант оператора представляет собой ключевое слово`if`, за которым, в скобках, записывают проверяемое выражение, а затем — команду, которую нужно выполнить, если выражение истинно.  
  
Например, есть такой файл с именем`testfile`:  
  

```
10
15
6
33
45
```

  
Напишем скрипт, который выводит числа из этого файла, большие 20:  
  

```
$ awk '{if ($1 > 20) print $1}' testfile
```

  

![](/images/bfa877e321ef62fba8c76da8e967d751.png)

  
_Однострочный оператор if_  
  
Если нужно выполнить в блоке`if`несколько операторов, их нужно заключить в фигурные скобки:  
  

```
$ awk '{
if ($1 > 20)
{
x = $1 * 2
print x
}
}' testfile
```

  

![](/images/8e1c0b8db9cffa7428dda1af8bf3ebcb.png)

  
_Выполнение нескольких команд в блоке if_  
  
Как уже было сказано, условный оператор awk может содержать блок`else`:  
  

```
$ awk '{
if ($1 > 20)
{
x = $1 * 2
print x
} else
{
x = $1 / 2
print x
}}' testfile
```

  

![](/images/c53ec3762242952c072e9277b5d97593.png)

  
_Условный оператор с блоком else_  
  
Ветвь`else`может быть частью однострочной записи условного оператора, включая в себя лишь одну строку с командой. В подобном случае после ветви`if`, сразу перед`else`, надо поставить точку с запятой:  
  

```
$ awk '{if ($1 > 20) print $1 * 2; else print $1 / 2}' testfile
```

  

![](/images/e002f0a1a7d37436714f9f5fc93c8c73.png)

  
_Условный оператор, содержащий ветви if и else, записанный в одну строку_  
  

## Цикл while

  
Цикл`while`позволяет перебирать наборы данных, проверяя условие, которое остановит цикл.  
  
Вот файл`myfile`, обработку которого мы хотим организовать с помощью цикла:  
  

```
124 127 130
112 142 135
175 158 245
```

  
Напишем такой скрипт:  
  

```
$ awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
i++
}
avg = total / 3
print "Average:",avg
}' testfile
```

  

![](/images/qUE7sqkjSz-nGb4j4dYU15V0M9eLPXSuztbbmFCsjPzJEXRL-xosMnw2fdMd_4YAv_5fFnvt3Pijrggt_nt0vmoLzzfycbI8Uhh57lNMPu0TSYN-Y-mTWKozYoxrqy5Uz3jHDkcRnumMMnQUkw)

  
_Обработка данных в цикле while_  
  
Цикл`while`перебирает поля каждой записи, накапливая их сумму в переменной`total`и увеличивая в каждой итерации на 1 переменную-счётчик`i`. Когда`i`достигнет 4, условие на входе в цикл окажется ложным и цикл завершится, после чего будут выполнены остальные команды — подсчёт среднего значения для числовых полей текущей записи и вывод найденного значения.  
  
В циклах`while`можно использовать команды`break`и`continue`. Первая позволяет досрочно завершить цикл и приступить к выполнению команд, расположенных после него. Вторая позволяет, не завершая до конца текущую итерацию, перейти к следующей.  
  
Вот как работает команда`break`:  
  

```
$ awk '{
total = 0
i = 1
while (i < 4)
{
total += $i
if (i == 2)
break
i++
}
avg = total / 2
print "The average of the first two elements is:",avg
}' testfile
```

  

![](/images/0VV0H2jGWnzz9I7z7GaQskjeH7qhM06ut-ssXOOA0HODAF5Tp801r9YD7j2xLQlAtJpBUwGkacfB7tz2SH4ZFcR2j-zRl6KNUZMGhVeZgv8t2PEvK2r4CQ8DfLkYGqf7_RJRtrYj20i-NMKn3w)

  
_Команда break в цикле while_  
  

## Цикл for

  
Циклы`for`используются во множестве языков программировании. Поддерживает их и awk. Решим задачу расчёта среднего значения числовых полей с использованием такого цикла:  
  

```
$ awk '{
total = 0
for (i = 1; i < 4; i++)
{
total += $i
}
avg = total / 3
print "Average:",avg
}' testfile
```

  

![](/images/hmsFRQrUjqzTNGTmOf42XfHPjerCVY3y8EWViFKrXFBkugCrKSmgz0ei_JK3LSkOfqQDgok0iqOGgRk3LUKdhbLXNP_7iyxjOe_2hi-iObr1QxrMIWkWvYizkxUPXTiirZetpmn4vL2kBqFHvg)

  
_Цикл for_  
  
Начальное значение переменной-счётчика и правило её изменения в каждой итерации, а также условие прекращения цикла, задаются в начале цикла, в круглых скобках. В итоге нам не нужно, в отличие от случая с циклом`while`, самостоятельно инкрементировать счётчик.  
  

## Форматированный вывод данных

  
Команда`printf`в awk позволяет выводить форматированные данные. Она даёт возможность настраивать внешний вид выводимых данных благодаря использованию шаблонов, в которых могут содержаться текстовые данные и спецификаторы форматирования.  
  
Спецификатор форматирования — это специальный символ, который задаёт тип выводимых данных и то, как именно их нужно выводить. Awk использует спецификаторы форматирования как указатели мест вставки данных из переменных, передаваемых`printf`.  
  
Первый спецификатор соответствует первой переменной, второй спецификатор — второй, и так далее.  
  
Спецификаторы форматирования записывают в таком виде:  
  

```
%[modifier]control-letter
```

  
Вот некоторые из них:  

> `c`— воспринимает переданное ему число как код ASCII-символа и выводит этот символ.  
> `d`— выводит десятичное целое число.  
> `i`— то же самое, что и`d`.  
> `e`— выводит число в экспоненциальной форме.  
> `f`— выводит число с плавающей запятой.  
> `g`— выводит число либо в экспоненциальной записи, либо в формате с плавающей запятой, в зависимости от того, как получается короче.  
> `o`— выводит восьмеричное представление числа.  
> `s`— выводит текстовую строку.

  
Вот как форматировать выводимые данные с помощью`printf`:  
  

```
$ awk 'BEGIN{
x = 100 * 100
printf "The result is: %e\n", x
}'
```

  

![](/images/32PdPiqkHvNTKbPq6tfVcEyb9se3YI54X_UA2yJbOWlJ5KYJfxTFTWTaXALHOIWO-WD5Bn79Q7b0c6wW6gUnL83WaqKxMvv8z3OGeZh5WEiLRbEYK0DHXfUtQMSPkykZsOhIpH5M2-wARhCvYw)

  
_Форматирование выходных данных с помощью printf_  
  
Тут, в качестве примера, мы выводим число в экспоненциальной записи. Полагаем, этого достаточно для того, чтобы вы поняли основную идею, на которой построена работа с`printf`.  
  

## Встроенные математические функции

  
При работе с awk программисту доступны[встроенные функции](https://www.gnu.org/software/gawk/manual/html_node/Built_002din.html#Built_002din). В частности, это математические и строковые функции, функции для работы со временем. Вот, например, список математических функций, которыми можно пользоваться при разработке awk-скриптов:  

> `cos(x)`— косинус`x`(`x`выражено в радианах).  
> `sin(x)`— синус`x`.  
> `exp(x)`— экспоненциальная функция.  
> `int(x)`— возвращает целую часть аргумента.  
> `log(x)`— натуральный логарифм.  
> `rand()`— возвращает случайное число с плавающей запятой в диапазоне 0 — 1.  
> `sqrt(x)`— квадратный корень из`x`.

  
Вот как пользоваться этими функциями:  
  

```
$ awk 'BEGIN{x=exp(5); print x}'
```

  

![](/images/wFI2nUqVLj0duMPEafJs2MtGk7oETB1zCsm53GTzG30l5UjYDWb3igdtB_DULzzN8Mu40_XdSUoZj9egx-nCl11ct_-hcukCfcAVQ-CvD5qUCflo_h8CfVYvNZyWG6DNRJOg4QWW_huMOioX9Q)

  
_Работа с математическими функциями_  
  

## Строковые функции

  
Awk поддерживает множество[строковых функций](https://www.gnu.org/software/gawk/manual/html_node/String-Functions.html#String-Functions). Все они устроены более или менее одинаково. Вот, например, функция`toupper`:  
  

```
$ awk 'BEGIN{x = "likegeeks"; print toupper(x)}'
```

  

![](/images/1ef4HRdqEbczINRJIehv3fZ4737nmYjqj7BcDKnEIw9oQlV_KQEbn2QSGXsCT79jV6AHJify_Ik0RtTQiXTlO802hycQdkx4dLN_nJV4AeRX-zsGsu8JUSKszyfxZUq2daDZ-fYd752qViDdFQ)

  
_Использование строковой функции toupper_  
  
Эта функция преобразует символы, хранящиеся в переданной ей строковой переменной, к верхнему регистру.  
  

## Пользовательские функции

  
При необходимости вы можете создавать собственные функции awk. Такие функции можно использовать так же, как встроенные:  
  

```
$ awk '
function myprint()
{
printf "The user %s has home path at %s\n", $1,$6
}
BEGIN{FS=":"}
{
myprint()
}' /etc/passwd
```

  

![](/images/BTkYWVuNkMUnAHf4hA1ZksVnjTd68TMa6Drb04hnCqa8IxjR4TBTyA_r6u5CNz6fWCEy32nJIOV9J4Aj1gFqDXaeL8IjOZD76aj4cOBTfUi_Zp6kjlQ_LzoFFDiRV8NWuTVmV5bnJtn-9yHvqA)

  
_Использование собственной функции_  
  
В примере используется заданная нами функция`myprint`, которая выводит данные.

# Bash-скрипты, часть 9: регулярные выражения

## Что такое регулярные выражения

  
У многих, когда они впервые видят регулярные выражения, сразу же возникает мысль, что перед ними бессмысленное нагромождение символов. Но это, конечно, далеко не так. Взгляните, например, на это регулярное выражение  
  

```
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$
```

  
На наш взгляд даже абсолютный новичок сходу поймёт, как оно устроено и зачем нужно :) Если же вам не вполне понятно — просто читайте дальше и всё встанет на свои места.  
Регулярное выражение — это шаблон, пользуясь которым программы вроде sed или awk фильтруют тексты. В шаблонах используются обычные ASCII-символы, представляющие сами себя, и так называемые метасимволы, которые играют особую роль, например, позволяя ссылаться на некие группы символов.  
  

## Типы регулярных выражений

  
Реализации регулярных выражений в различных средах, например, в языках программирования вроде Java, Perl и Python, в инструментах Linux вроде sed, awk и grep, имеют определённые особенности. Эти особенности зависят от так называемых движков обработки регулярных выражений, которые занимаются интерпретацией шаблонов.  
В Linux имеется два движка регулярных выражений:  
  

*   Движок, поддерживающий стандарт POSIX Basic Regular Expression (BRE).
*   Движок, поддерживающий стандарт POSIX Extended Regular Expression (ERE).

  
Большинство утилит Linux соответствуют, как минимум, стандарту POSIX BRE, но некоторые утилиты (в их числе — sed) понимают лишь некое подмножество стандарта BRE. Одна из причин такого ограничения — стремление сделать такие утилиты как можно более быстрыми в деле обработки текстов.  
  
Стандарт POSIX ERE часто реализуют в языках программирования. Он позволяет пользоваться большим количеством средств при разработке регулярных выражений. Например, это могут быть специальные последовательности символов для часто используемых шаблонов, вроде поиска в тексте отдельных слов или наборов цифр. Awk поддерживает стандарт ERE.  
  
Существует много способов разработки регулярных выражений, зависящих и от мнения программиста, и от особенностей движка, под который их создают. Непросто писать универсальные регулярные выражения, которые сможет понять любой движок. Поэтому мы сосредоточимся на наиболее часто используемых регулярных выражениях и рассмотрим особенности их реализации для sed и awk.  
  

## Регулярные выражения POSIX BRE

  
Пожалуй, самый простой шаблон BRE представляет собой регулярное выражение для поиска точного вхождения последовательности символов в тексте. Вот как выглядит поиск строки в sed и awk:  
  

```
$ echo "This is a test" | sed -n '/test/p'
$ echo "This is a test" | awk '/test/{print $0}'
```

  

![](/images/ce151e066cd663f4df98e840831073ca.png)

  
_Поиск текста по шаблону в sed_  
  

![](/images/9de8f4b471c6480e773c3de4301b5d0b.png)

  
_Поиск текста по шаблону в awk_  
  
Можно заметить, что поиск заданного шаблона выполняется без учёта точного места нахождения текста в строке. Кроме того, не имеет значение и количество вхождений. После того, как регулярное выражение найдёт заданный текст в любом месте строки, строка считается подходящей и передаётся для дальнейшей обработки.  
  
Работая с регулярными выражениями нужно учитывать то, что они чувствительны к регистру символов:  
  

```
$ echo "This is a test" | awk '/Test/{print $0}'
$ echo "This is a test" | awk '/test/{print $0}'
```

  

![](/images/a3414cd2cb6e497e44544ea3fa306f1f.png)

  
_Регулярные выражения чувствительны к регистру_  
  
Первое регулярное выражение совпадений не нашло, так как слово «test», начинающееся с заглавной буквы, в тексте не встречается. Второе же, настроенное на поиск слова, написанного прописными буквами, обнаружило в потоке подходящую строку.  
  
В регулярных выражениях можно использовать не только буквы, но и пробелы, и цифры:  
  

```
$ echo "This is a test 2 again" | awk '/test 2/{print $0}'
```

  

![](/images/aab02260a27124770cd425bd16c66a83.png)

  
_Поиск фрагмента текста, содержащего пробелы и цифры_  
  
Пробелы воспринимаются движком регулярных выражений как обычные символы.  
  

## Специальные символы

  
При использовании различных символов в регулярных выражениях надо учитывать некоторые особенности. Так, существуют некоторые специальные символы, или метасимволы, использование которых в шаблоне требует особого подхода. Вот они:  
  

```
.*[]^${}\+?|()
```

  
Если один из них нужен в шаблоне, его нужно будет экранировать с помощью обратной косой черты (обратного слэша) —`\`.  
  
Например, если в тексте нужно найти знак доллара, его надо включить в шаблон, предварив символом экранирования. Скажем, имеется файл`myfile`с таким текстом:  
  

```
There is 10$ on my pocket
```

  
Знак доллара можно обнаружить с помощью такого шаблона:  
  

```
$ awk '/\$/{print $0}' myfile
```

  

![](/images/2e2056628c28fd1d141bf3cc9d7253a7.png)

  
_Использование в шаблоне специального символа_  
  
Кроме того, обратная косая черта — это тоже специальный символ, поэтому, если нужно использовать его в шаблоне, его тоже надо будет экранировать. Выглядит это как два слэша, идущих друг за другом:  
  

```
$ echo "\ is a special character" | awk '/\\/{print $0}'
```

  

![](/images/47a18f06c8a463f39d15da1f8bfd677a.png)

  
_Экранирование обратного слэша_  
  
Хотя прямой слэш и не входит в приведённый выше список специальных символов, попытка воспользоваться им в регулярном выражении, написанном для sed или awk, приведёт к ошибке:  
  

```
$ echo "3 / 2" | awk '///{print $0}'
```

  

![](/images/0668a1e77511ed32970f60b26cd597e7.png)

  
_Неправильное использование прямого слэша в шаблоне_  
  
Если он нужен, его тоже надо экранировать:  
  

```
$ echo "3 / 2" | awk '/\//{print $0}'
```

  

![](/images/13dde2d8afe39a863e124712188a95b2.png)

  
_Экранирование прямого слэша_  
  

## Якорные символы

  
Существуют два специальных символа для привязки шаблона к началу или к концу текстовой строки. Символ «крышка» —`^`позволяет описывать последовательности символов, которые находятся в начале текстовых строк. Если искомый шаблон окажется в другом месте строки, регулярное выражение на него не отреагирует. Выглядит использование этого символа так:  
  

```
$ echo "welcome to likegeeks website" | awk '/^likegeeks/{print $0}'
$ echo "likegeeks website" | awk '/^likegeeks/{print $0}'
```

  

![](/images/b64da5ad11297c7f97de46f83dcda1da.png)

  
_Поиск шаблона в начале строки_  
  
Символ`^`предназначен для поиска шаблона в начале строки, при этом регистр символов так же учитывается. Посмотрим, как это отразится на обработке текстового файла:  
  

```
$ awk '/^this/{print $0}' myfile
```

  

![](/images/1fb810f9bb775d412ae5c3748e78e42c.png)

  
_Поиск шаблона в начале строки в тексте из файла_  
  
При использовании sed, если поместить крышку где-нибудь внутри шаблона, она будет восприниматься как любой другой обычный символ:  
  

```
$ echo "This ^ is a test" | sed -n '/s ^/p'
```

  

![](/images/6eeebad801eeb799f1208331658ee6ef.png)

  
_Крышка, находящаяся не в начале шаблона в sed_  
  
В awk, при использовании такого же шаблона, данный символ надо экранировать:  
  

```
$ echo "This ^ is a test" | awk '/s \^/{print $0}'
```

  

![](/images/fbba19a69e7814891f9d4c89e11c8414.png)

  
_Крышка, находящаяся не в начале шаблона в awk_  
  
С поиском фрагментов текста, находящихся в начале строки мы разобрались. Что, если надо найти нечто, расположенное в конце строки?  
  
В этом нам поможет знак доллара —`$`, являющийся якорным символом конца строки:  
  

```
$ echo "This is a test" | awk '/test$/{print $0}'
```

  

![](/images/b9a0400d5b963002ac59d3fc895f8f4f.png)

  
_Поиск текста, находящегося в конце строки_  
  
В одном и том же шаблоне можно использовать оба якорных символа. Выполним обработку файла`myfile`, содержимое которого показано на рисунке ниже, с помощью такого регулярного выражения:  
  

```
$ awk '/^this is a test$/{print $0}' myfile
```

  

![](/images/d1521b87b3ec1b32658b612b590c0f99.png)

  
_Шаблон, в котором использованы специальные символы начала и конца строки_  
  
Как видно, шаблон среагировал лишь на строку, полностью соответствующую заданной последовательности символов и их расположению.  
  
Вот как, пользуясь якорными символами, отфильтровать пустые строки:  
  

```
$ awk '!/^$/{print $0}' myfile
```

  
В данном шаблоне использовал символ отрицания, восклицательный знак —`!`. Благодаря использованию такого шаблона выполняется поиск строк, не содержащих ничего между началом и концом строки, а благодаря восклицательному знаку на печать выводятся лишь строки, которые не соответствуют этому шаблону.  
  

## Символ «точка»

  
Точка используется для поиска любого одиночного символа, за исключением символа перевода строки. Передадим такому регулярному выражению файл`myfile`, содержимое которого приведено ниже:  
  

```
$ awk '/.st/{print $0}' myfile
```

  

![](/images/4a52d7200df95c30531ccc7a4a4924b1.png)

  
_Использование точки в регулярных выражениях_  
  
Как видно по выведенным данным, шаблону соответствуют лишь первые две строки из файла, так как они содержат последовательность символов «st», предварённую ещё одним символом, в то время как третья строка подходящей последовательности не содержит, а в четвёртой она есть, но находится в самом начале строки.  
  

## Классы символов

  
Точка соответствует любому одиночному символу, но что если нужно более гибко ограничить набор искомых символов? В подобной ситуации можно воспользоваться классами символов.  
  
Благодаря такому подходу можно организовать поиск любого символа из заданного набора. Для описания класса символов используются квадратные скобки —`[]`:  
  

```
$ awk '/[oi]th/{print $0}' myfile
```

  

![](/images/f84e0a6441893131f42b3892486d467d.png)

  
_Описание класса символов в регулярном выражении_  
  
Тут мы ищем последовательность символов «th», перед которой есть символ «o» или символ «i».  
  
Классы оказываются очень кстати, если выполняется поиск слов, которые могут начинаться как с прописной, так и со строчной буквы:  
  

```
$ echo "this is a test" | awk '/[Tt]his is a test/{print $0}'
$ echo "This is a test" | awk '/[Tt]his is a test/{print $0}'
```

  

![](/images/3d9f658a231a01771a5fc209b1cd086a.png)

  
_Поиск слов, которые могут начинаться со строчной или прописной буквы_  
  
Классы символов не ограничены буквами. Тут можно использовать и другие символы. Нельзя заранее сказать, в какой ситуации понадобятся классы — всё зависит от решаемой задачи.  
  

## Отрицание классов символов

  
Классы символов можно использовать и для решения задачи, обратной описанной выше. А именно, вместо поиска символов, входящих в класс, можно организовать поиск всего, что в класс не входит. Для того, чтобы добиться такого поведения регулярного выражения, перед списком символов класса нужно поместить знак`^`. Выглядит это так:  
  

```
$ awk '/[^oi]th/{print $0}' myfile
```

  

![](/images/ba4ae6853c092785c6c9db33bee0e9d8.png)

  
_Поиск символов, не входящих в класс_  
  
В данном случае будут найдены последовательности символов «th», перед которыми нет ни «o», ни «i».  
  

## Диапазоны символов

  
В символьных классах можно описывать диапазоны символов, используя тире:  
  

```
$ awk '/[e-p]st/{print $0}' myfile
```

  

![](/images/646f128aa44e661a023b6e721d81f020.png)

  
_Описание диапазона символов в символьном классе_  
  
В данном примере регулярное выражение реагирует на последовательность символов «st», перед которой находится любой символ, расположенный, в алфавитном порядке, между символами «e» и «p».  
  
Диапазоны можно создавать и из чисел:  
  

```
$ echo "123" | awk '/[0-9][0-9][0-9]/'
$ echo "12a" | awk '/[0-9][0-9][0-9]/'
```

  

![](/images/8101e448b27a7c9cb9c56fc0434adc0a.png)

  
_Регулярное выражение для поиска трёх любых чисел_  
  
В класс символов могут входить несколько диапазонов:  
  

```
$ awk '/[a-fm-z]st/{print $0}' myfile
```

  

![](/images/7e99996235e70b1dc907315343ae9b01.png)

  
_Класс символов, состоящий из нескольких диапазонов_  
  
Данное регулярное выражение найдёт все последовательности «st», перед которыми есть символы из диапазонов`a-f`и`m-z`.  
  

## Специальные классы символов

  
В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:  
  

*   `[[:alpha:]]` — соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре.
*   `[[:alnum:]]` — соответствует любому алфавитно-цифровому символу, а именно — символам в диапазонах`0-9`,`A-Z`,`a-z`.
*   `[[:blank:]]` — соответствует пробелу и знаку табуляции.
*   `[[:digit:]]` — любой цифровой символ от`0`до`9`.
*   `[[:upper:]]` — алфавитные символы в верхнем регистре —`A-Z`.
*   `[[:lower:]]` — алфавитные символы в нижнем регистре —`a-z`.  
*   `[[:print:]]` — соответствует любому печатаемому символу.
*   `[[:punct:]]` — соответствует знакам препинания.
*   `[[:space:]]` — пробельные символы, в частности — пробел, знак табуляции, символы`NL`,`FF`,`VT`,`CR`.

  
Использовать специальные классы в шаблонах можно так:  
  

```
$ echo "abc" | awk '/[[:alpha:]]/{print $0}'
$ echo "abc" | awk '/[[:digit:]]/{print $0}'
$ echo "abc123" | awk '/[[:digit:]]/{print $0}'
```

  

![](/images/4e2386e8bce40ead25463d12945199f0.png)

  
_Специальные классы символов в регулярных выражениях_  
  

## Символ «звёздочка»

  
Если в шаблоне после символа поместить звёздочку, это будет означать, что регулярное выражение сработает, если символ появляется в строке любое количество раз — включая и ситуацию, когда символ в строке отсутствует.  
  

```
$ echo "test" | awk '/tes*t/{print $0}'
$ echo "tessst" | awk '/tes*t/{print $0}'
```

  

![](/images/0f704b9ad0e6db2349a5257a35a42b8f.png)

  
_Использование символа \* в регулярных выражениях_  
  
Этот шаблонный символ обычно используют для работы со словами, в которых постоянно встречаются опечатки, или для слов, допускающих разные варианты корректного написания:  
  

```
$ echo "I like green color" | awk '/colou*r/{print $0}'
$ echo "I like green colour " | awk '/colou*r/{print $0}'
```

  

![](/images/fb8bbd4a6cda3194f5438e44ec0d19a2.png)

  
_Поиск слова, имеющего разные варианты написания_  
  
В этом примере одно и то же регулярное выражение реагирует и на слово «color», и на слово «colour». Это так благодаря тому, что символ «u», после которого стоит звёздочка, может либо отсутствовать, либо встречаться несколько раз подряд.  
  
Ещё одна полезная возможность, вытекающая из особенностей символа звёздочки, заключается в комбинировании его с точкой. Такая комбинация позволяет регулярному выражению реагировать на любое количество любых символов:  
  

```
$ awk '/this.*test/{print $0}' myfile
```

  

![](/images/078f4349a99b37584cfc11404d373178.png)

  
_Шаблон, реагирующий на любое количество любых символов_  
  
В данном случае неважно сколько и каких символов находится между словами «this» и «test».  
  
Звёздочку можно использовать и с классами символов:  
  

```
$ echo "st" | awk '/s[ae]*t/{print $0}'
$ echo "sat" | awk '/s[ae]*t/{print $0}'
$ echo "set" | awk '/s[ae]*t/{print $0}'
```

  

![](/images/0b43c8413d2fd63352a82d6cb3a1909e.png)

  
_Использование звёздочки с классами символов_  
  
Во всех трёх примерах регулярное выражение срабатывает, так как звёздочка после класса символов означает, что если будет найдено любое количество символов «a» или «e», а также если их найти не удастся, строка будет соответствовать заданному шаблону.  
  

## Регулярные выражения POSIX ERE

  
Шаблоны стандарта POSIX ERE, которые поддерживают некоторые утилиты Linux, могут содержать дополнительные символы. Как уже было сказано, awk поддерживает этот стандарт, а вот sed — нет.  
  
Тут мы рассмотрим наиболее часто используемые в ERE-шаблонах символы, которые пригодятся вам при создании собственных регулярных выражений.  
  

### Вопросительный знак

  
Вопросительный знак указывает на то, что предшествующий символ может встретиться в тексте один раз или не встретиться вовсе. Этот символ — один из метасимволов повторений. Вот несколько примеров:  
  

```
$ echo "tet" | awk '/tes?t/{print $0}'
$ echo "test" | awk '/tes?t/{print $0}'
$ echo "tesst" | awk '/tes?t/{print $0}'
```

  

![](/images/9e66ae7580f900e395dd762497f36a39.png)

  
_Вопросительный знак в регулярных выражениях_  
  
Как видно, в третьем случае буква «s» встречается дважды, поэтому на слово «tesst» регулярное выражение не реагирует.  
  
Вопросительный знак можно использовать и с классами символов:  
  

```
$ echo "tst" | awk '/t[ae]?st/{print $0}'
$ echo "test" | awk '/t[ae]?st/{print $0}'
$ echo "tast" | awk '/t[ae]?st/{print $0}'
$ echo "taest" | awk '/t[ae]?st/{print $0}'
$ echo "teest" | awk '/t[ae]?st/{print $0}'
```

  

![](/images/be8fe31e3f05cf44b2176c9e300bbc74.png)

  
_Вопросительный знак и классы символов_  
  
Если символов из класса в строке нет, или один из них встречается один раз, регулярное выражение срабатывает, однако стоит в слове появиться двум символам и система уже не находит в тексте соответствия шаблону.  
  

### Символ «плюс»

  
Символ «плюс» в шаблоне указывает на то, что регулярное выражение обнаружит искомое в том случае, если предшествующий символ встретится в тексте один или более раз. При этом на отсутствие символа такая конструкция реагировать не будет:  
  

```
$ echo "test" | awk '/te+st/{print $0}'
$ echo "teest" | awk '/te+st/{print $0}'
$ echo "tst" | awk '/te+st/{print $0}'
```

  

![](/images/d645c9a064e8c4af30d83ee3a21c6f56.png)

  
_Символ «плюс» в регулярных выражениях_  
  
В данном примере, если символа «e» в слове нет, движок регулярных выражений не найдёт в тексте соответствий шаблону. Символ «плюс» работает и с классами символов — этим он похож на звёздочку и вопросительный знак:  
  

```
$ echo "tst" | awk '/t[ae]+st/{print $0}'
$ echo "test" | awk '/t[ae]+st/{print $0}'
$ echo "teast" | awk '/t[ae]+st/{print $0}'
$ echo "teeast" | awk '/t[ae]+st/{print $0}'
```

  

![](/images/c776a778eabbfcf0dd0a77f98c26175c.png)

  
_Знак «плюс» и классы символов_  
  
В данном случае если в строке имеется любой символ из класса, текст будет сочтён соответствующим шаблону.  
  

### Фигурные скобки

  
Фигурные скобки, которыми можно пользоваться в ERE-шаблонах, похожи на символы, рассмотренные выше, но они позволяют точнее задавать необходимое число вхождений предшествующего им символа. Указывать ограничение можно в двух форматах:  
  

*   `n —`число, задающее точное число искомых вхождений  
    
*   `n, m —`два числа, которые трактуются так: «как минимум n раз, но не больше чем m».  
    

  
Вот примеры первого варианта:  
  

```
$ echo "tst" | awk '/te{1}st/{print $0}'
$ echo "test" | awk '/te{1}st/{print $0}'
```

  

![](/images/4acc402e59676f3630b5b73d12ff7cfa.png)

  
_Фигурные скобки в шаблонах, поиск точного числа вхождений_  
  
В старых версиях awk нужно было использовать ключ командной строки`--re-interval`для того, чтобы программа распознавала интервалы в регулярных выражениях, но в новых версиях этого делать не нужно.  
  

```
$ echo "tst" | awk '/te{1,2}st/{print $0}'
$ echo "test" | awk '/te{1,2}st/{print $0}'
$ echo "teest" | awk '/te{1,2}st/{print $0}'
$ echo "teeest" | awk '/te{1,2}st/{print $0}'
```

  

![](/images/7ba0c03f5020b615812530ca2af99b13.png)

  
_Интервал, заданный в фигурных скобках_  
  
В данном примере символ «e» должен встретиться в строке 1 или 2 раза, тогда регулярное выражение отреагирует на текст.  
  
Фигурные скобки можно применять и с классами символов. Тут действуют уже знакомые вам принципы:  
  

```
$ echo "tst" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "test" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "teest" | awk  '/t[ae]{1,2}st/{print $0}'
$ echo "teeast" | awk  '/t[ae]{1,2}st/{print $0}'
```

  

![](/images/88ee9703a9d01a0200e19f6bef7096b3.png)

  
_Фигурные скобки и классы символов_  
  
Шаблон отреагирует на текст в том случае, если в нём один или два раза встретится символ «a» или символ «e».  
  

### Символ логического «или»

  
Символ`|`— вертикальная черта, означает в регулярных выражениях логическое «или». Обрабатывая регулярное выражение, содержащее несколько фрагментов, разделённых таким знаком, движок сочтёт анализируемый текст подходящим в том случае, если он будет соответствовать любому из фрагментов. Вот пример:  
  

```
$ echo "This is a test" | awk '/test|exam/{print $0}'
$ echo "This is an exam" | awk '/test|exam/{print $0}'
$ echo "This is something else" | awk '/test|exam/{print $0}'
```

  

![](/images/3b55b74f1cf11a6aafdbd4839413d31c.png)

  
_Логическое «или» в регулярных выражениях_  
  
В данном примере регулярное выражение настроено на поиск в тексте слов «test» или «exam». Обратите внимание на то, что между фрагментами шаблона и разделяющим их символом`|`не должно быть пробелов.  
  

## Группировка фрагментов регулярных выражений

  
Фрагменты регулярных выражений можно группировать, пользуясь круглыми скобками. Если сгруппировать некую последовательность символов, она будет восприниматься системой как обычный символ. То есть, например, к ней можно будет применить метасимволы повторений. Вот как это выглядит:  
  

```
$ echo "Like" | awk '/Like(Geeks)?/{print $0}'
$ echo "LikeGeeks" | awk '/Like(Geeks)?/{print $0}'
```

  

![](/images/c78c80df73aa2c9817f53df90a067ad8.png)

  
_Группировка фрагментов регулярных выражений_  
  
В данных примерах слово «Geeks» заключено в круглые скобки, после этой конструкции идёт знак вопроса. Напомним, что вопросительный знак означает «0 или 1 повторение», в результате регулярное выражение отреагирует и на строку «Like», и на строку «LikeGeeks».  
  

## Практические примеры

  
После того, как мы разобрали основы регулярных выражений, пришло время сделать с их помощью что-нибудь полезное.  
  

### Подсчёт количества файлов

  
Напишем bash-скрипт, который подсчитывает файлы, находящиеся в директориях, которые записаны в переменную окружения`PATH`. Для того, чтобы это сделать, понадобится, для начала, сформировать список путей к директориям. Сделаем это с помощью sed, заменив двоеточия на пробелы:  
  

```
$ echo $PATH | sed 's/:/ /g'
```

  
Команда замены поддерживает регулярные выражения в качестве шаблонов для поиска текста. В данном случае всё предельно просто, ищем мы символ двоеточия, но никто не мешает использовать здесь и что-нибудь другое — всё зависит от конкретной задачи.  
Теперь надо пройтись по полученному списку в цикле и выполнить там необходимые для подсчёта количества файлов действия. Общая схема скрипта будет такой:  
  

```bash
mypath=$(echo $PATH | sed 's/:/ /g')
for directory in $mypath
 
do
 
done
```

  
Теперь напишем полный текст скрипта, воспользовавшись командой`ls`для получения сведений о количестве файлов в каждой из директорий:  
  

```bash
#!/bin/bash
mypath=$(echo $PATH | sed 's/:/ /g')
count=0
for directory in $mypath
do
check=$(ls $directory)
for item in $check
do
count=$[ $count + 1 ]
done
echo "$directory - $count"
count=0
done
```

  
При запуске скрипта может оказаться, что некоторых директорий из`PATH`не существует, однако, это не помешает ему посчитать файлы в существующих директориях.  
  

![](/images/75b6ef697cb8244cb70599f42d80c663.png)

  
_Подсчёт файлов_  
  
Главная ценность этого примера заключается в том, что пользуясь тем же подходом, можно решать и куда более сложные задачи. Какие именно — зависит от ваших потребностей.  
  

### Проверка адресов электронной почты

  
Существуют веб-сайты с огромными коллекциями регулярных выражений, которые позволяют проверять адреса электронной почты, телефонные номера, и так далее. Однако, одно дело — взять готовое, и совсем другое — создать что-то самому. Поэтому напишем регулярное выражение для проверки адресов электронной почты. Начнём с анализа исходных данных. Вот, например, некий адрес:  
  

```
username@hostname.com
```

  
Имя пользователя,`username`, может состоять из алфавитно-цифровых и некоторых других символов. А именно, это точка, тире, символ подчёркивания, знак «плюс». За именем пользователя следует знак @.  
  
Вооружившись этими знаниями, начнём сборку регулярного выражения с его левой части, которая служит для проверки имени пользователя. Вот что у нас получилось:  
  

```
^([a-zA-Z0-9_\-\.\+]+)@
```

  
Это регулярное выражение можно прочитать так: «В начале строки должен быть как минимум один символ из тех, которые имеются в группе, заданной в квадратных скобках, а после этого должен идти знак @».  
  
Теперь — очередь имени хоста —`hostname`. Тут применимы те же правила, что и для имени пользователя, поэтому шаблон для него будет выглядеть так:  
  

```
([a-zA-Z0-9_\-\.]+)
```

  
Имя домена верхнего уровня подчиняется особым правилам. Тут могут быть лишь алфавитные символы, которых должно быть не меньше двух (например, такие домены обычно содержат код страны), и не больше пяти. Всё это значит, что шаблон для проверки последней части адреса будет таким:  
  

```
\.([a-zA-Z]{2,5})$
```

  
Прочесть его можно так: «Сначала должна быть точка, потом — от 2 до 5 алфавитных символов, а после этого строка заканчивается».  
  
Подготовив шаблоны для отдельных частей регулярного выражения, соберём их вместе:  
  

```
^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$
```

  
Теперь осталось лишь протестировать то, что получилось:  
  

```
$ echo "name@host.com" | awk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/{print $0}'
$ echo "name@host.com.us" | awk '/^([a-zA-Z0-9_\-\.\+]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/{print $0}'
```

  

![](/images/9a5f01a6058b364523a8241e5f35c344.png)

  
_Проверка адреса электронной почты с помощью регулярных выражений_  
  
То, что переданный awk текст выводится на экран, означает, что система распознала в нём адрес электронной почты.


# Bash-скрипты, часть 10: практические примеры

## Отправка сообщений в терминал пользователя

  
В наши дни редко кто прибегает к одной из возможностей Linux, которая позволяет общаться, отправляя сообщения в терминалы пользователей, вошедших в систему. Сама по себе команда отправки сообщений,`write`, довольно проста. Для того, чтобы ей воспользоваться, достаточно знать имя пользователя и имя его терминала. Однако, для успешной отправки сообщения, помимо актуальных данных о пользователе и терминале, надо знать, вошёл ли пользователь в систему, не запретил ли он запись в свой терминал. В результате, перед отправкой сообщения нужно выполнить несколько проверок.  
  
Как видите, задача: «отправить сообщение», при ближайшем рассмотрении, оказалась задачей: «проверить возможность отправки сообщения, и, если нет препятствий, отправить его». Займёмся решением задачи, то есть — разработкой bash-скрипта.  
  

### Команды who и mesg

  
Ядром скрипта являются несколько команд, которые мы ещё не обсуждали. Всё остальное должно быть вам знакомо по предыдущим материалам.  
  
Первое, что нам тут понадобится — команда`who`. Она позволяет узнать сведения о пользователях, работающих в системе. В простейшем виде её вызов выглядит так:  
  

```
$ who
```

  

![](/images/5d04710940fc2750d0f14b5b14d197d1.png)

  
_Результаты вызова команды who_  
  
В каждой строчке, которую выводит команда`who`, нас интересуют первых два показателя — имя пользователя и сведения о его терминале.  
  
По умолчанию запись в терминал разрешена, но пользователь может, с помощью команды`mesg`, запретить отправку ему сообщений. Таким образом, прежде чем пытаться что-то кому-то отправить, неплохо будет проверить, разрешена ли отправка сообщений. Если нужно узнать собственный статус, достаточно ввести команду`mesg`без параметров:  
  

```
$ mesg
```

  

![](/images/6753391a3a4aeed1acae38862ac9d883.png)

  
_Команда mesg_  
  
В данном случае команда вывела «is y», это значит, что пользователь, под которым мы работаем в системе, может принимать сообщения, отправленные в его терминал. В противном случае`mesg`выведет «is n».  
  
Для проверки того, разрешена ли отправка сообщений какому-то другому пользователю, можно использовать уже знакомую вам команду`who`с ключом`-T`:  
  

```
$ who -T
```

  
При этом проверка возможна только для пользователей, которые вошли в систему. Если такая команда, после имени пользователя, выведет чёрточку (-), это означает, что пользователь запретил запись в свой терминал, то есть, сообщения ему отправлять нельзя. О том, что пользователю можно отправлять сообщения, говорит знак «плюс» (+).  
  
Если у вас приём сообщений отключён, а вы хотите позволить другим пользователям отправлять вам сообщения, можно воспользоваться такой командой:  
  

```
$ mesg y
```

  

![](/images/f01eda2dc79b7040fd3d144aa06d676d.png)

  
_Включение приёма сообщений от других пользователей_  
  
После включения приёма сообщений`mesg`возвращает «is y».  
Конечно, для обмена сообщениями нужны два пользователя, поэтому мы, после обычного входа в систему, подключились к компьютеру по ssh. Теперь можно поэкспериментировать.  
  

### Команда write

  
Основной инструмент для обмена сообщениями между пользователями, вошедшими в систему — команда`write`. Если приём сообщений у пользователя разрешён, с помощью этой команды ему можно отправлять сообщения, используя его имя и сведения о терминале.  
  
Обратите внимание на то, что с помощью`write`можно отправлять сообщения пользователям, вошедшим в виртуальную консоль. Пользователи, которые работают в графическом окружении (KDE, Gnome, Cinnamon, и так далее), не могут получать подобные сообщения.  
  
Итак, мы, работая под пользователем`likegeeks`, инициируем сеанс связи с пользователем`testuser`, который работает в терминале`pts/1`, следующим образом:  
  

```
$ write testuser pts/1
```

  

![](/images/511a3970ab4a8546fd6ff1f07f87a307.png)

  
_Проверка возможности отправки сообщений и отправка сообщения_  
  
После выполнения вышеуказанной команды перед нами окажется пустая строка, в которую нужно ввести первую строку сообщения. Нажав клавишу`ENTER`, мы можем ввести следующую строку сообщения. После того, как ввод текста завершён, окончить сеанс связи можно, воспользовавшись комбинацией клавиш`CTRL + D`, которая позволяет ввести[символ конца файла](https://habrahabr.ru/company/ruvds/blog/326826/).  
  
Вот что увидит в своём терминале пользователь, которому мы отправили сообщение.  
  

![](/images/a9551626918b606b20c58d9e30ed8ea0.png)

  
_Новое сообщение, пришедшее в терминал_  
  
Получатель может понять от кого пришло сообщение, увидеть время, когда оно было отправлено. Обратите внимание на признак конца файла,`EOF`, расположенный в нижней части окна терминала. Он указывает на окончание текста сообщения.  
  
Полагаем, теперь у нас есть всё необходимое для того, чтобы автоматизировать отправку сообщений с помощью сценария командной строки.  
  

### Создание скрипта для отправки сообщений

  
Прежде чем заниматься отправкой сообщений, нужно определить, вошёл ли интересующий нас пользователь в систему. Сделать это можно с помощью такой команды:  
  

```
logged_on=$(who | grep -i -m 1 $1 | awk '{print $1}')
```

  
Здесь результаты работы команды`who`передаются команде`grep`. Ключ`-i`этой команды позволяет игнорировать регистр символов. Ключ`-m 1`включён в вызов команды на тот случай, если пользователь вошёл в систему несколько раз. Эта команда либо не выведет ничего, либо выведет имя пользователя (его мы укажем при вызове скрипта, оно попадёт в позиционную переменную`$1`), соответствующее первому найденному сеансу. Вывод`grep`мы передаём`awk`. Эта команда, опять же, либо не выведет ничего, либо выведет элемент, записанный в собственную переменную`$1`, то есть — имя пользователя. В итоге то, что получилось, попадает в переменную`logged_on`.  
  
Теперь надо проверить переменную l`ogged_on`, посмотреть, есть ли в ней что-нибудь:  
  

```bash
if [ -z $logged_on ]
then
echo "$1 is not logged on."
echo "Exit"
exit
fi
```

  
Если вы не вполне уверенно чувствуете себя, работая с конструкцией`if`, взгляните на[этот](https://habrahabr.ru/company/ruvds/blog/325522/)материал.  
Скрипт, содержащий вышеописанный код, сохраним в файле`senderscript`и вызовем, передав ему, в качестве параметра командной строки, имя пользователя`testuser`.  
  

![](/images/76150b96e45ce0d0fcb4eb0e536e0d4f.png)

  
_Проверка статуса пользователя_  
  
Тут мы проверяем, является ли`logged_on`переменной с нулевой длиной. Если это так, нам сообщат о том, что в данный момент пользователь в систему не вошёл и скрипт завершит работу с помощью команды`exit`. В противном случае выполнение скрипта продолжится.  
  

### Проверка возможности записи в терминал пользователя

  
Теперь надо проверить, принимает ли пользователь сообщения. Для этого понадобится такая конструкция, похожая на ту, которую мы использовали выше:  
  

```bash
allowed=$(who -T | grep -i -m 1 $1 | awk '{print $2}')
if [ $allowed != "+" ]
then
echo "$1 does not allowing messaging."
echo "Exit"
exit
fi
```

  

![](/images/a3e08cf12f617fd3ff123265f8342fcc.png)

  
_Проверка возможности отправки сообщений пользователю_  
  
Сначала мы вызываем команду`who`с ключом`-T`. В строке сведений о пользователе, который может принимать сообщения, окажется знак «плюс» (+), если же пользователь принимать сообщения не может — там будет чёрточка (-). То, что получилось после вызова`who`, передаётся`grep`, а потом —`awk`, формируя переменную`allowed`.  
  
Далее, используя условный оператор, мы проверяем то, что оказалось в переменной`allowed`. Если знака «плюс» в ней нет, сообщим о том, что отправка сообщений пользователю запрещена и завершим работу. В противном случае выполнение сценария продолжится.  
  

### Проверка правильности вызова скрипта

  
Первым параметром скрипта является имя пользователя, которому мы хотим отправить сообщение. Вторым — текст сообщения, в данном случае — состоящий из одного слова. Для того, чтобы проверить, передано ли скрипту сообщение для отправки, воспользуемся таким кодом:  
  

```bash
if [ -z $2 ]
then
echo "No message parameter included."
echo "Exit"
exit
fi
```

  

![](/images/63b910246e010ac396f28324de51ce10.png)

  
_Проверка параметров командной строки, указанных при вызове скрипта_  
  
Тут, если при вызове скрипта ему не было передано сообщение для отправки, мы сообщаем об этом и завершаем работу. В противном случае — идём дальше.  
  

### Получение сведений о терминале пользователя

  
Прежде чем отправить пользователю сообщение, нужно получить сведения о терминале, в котором он работает и сохранить имя терминала в переменной. Делается это так:  
  

```
terminal=$(who | grep -i -m 1 $1 | awk '{print $2}')
```

  
Теперь, после того, как все необходимые данные собраны, осталось лишь отправить сообщение:  
  

```
echo $2 | write $logged_on $terminal
```

  
Вызов готового скрипта выглядит так:  
  

```
$ ./senderscript testuser welcome
```

  

![](/images/a22e36dd5b5c6755fbba9efe3a8e09a7.png)

  
_Успешная отправка сообщения с помощью bash-скрипта_  
  
Как видно, всё работает как надо. Однако, с помощью такого сценария можно отправлять лишь сообщения, состоящие из одного слова. Хорошо бы получить возможность отправлять более длинные сообщения.  
  

### Отправка длинных сообщений

  
Попробуем вызвать сценарий`senderscript`, передав ему сообщение, состоящее из нескольких слов:  
  

```
$ ./senderscript likegeeks welcome to shell scripting
```

  

![](/images/6a8062728f8d848966abbd3bcf95a5ed.png)

  
_Попытка отправки длинного сообщения_  
  
Как видно, отправлено было лишь первое слово. Всё дело в том, что каждое слово сообщения воспринимается внутри скрипта как отдельная позиционная переменная. Для того, чтобы получить возможность отправки длинных сообщений, обработаем параметры командной строки, переданные сценарию, воспользовавшись[командой](https://habrahabr.ru/company/ruvds/blog/326328/)`shift`и циклом`while`.  
  

```bash
shift
while [ -n "$1" ]
do
whole_message=$whole_message' '$1
shift
done
```

  
После этого, в команде отправки сообщения, воспользуемся, вместо применяемой ранее позиционной переменной`$2`, переменной`whole_message`:  
  

```
echo $whole_message | write $logged_on $terminal
```

  
Вот полный текст сценария:  
  

```bash
#!/bin/bash
logged_on=$(who | grep -i -m 1 $1 | awk '{print $1}')
if [ -z $logged_on ]
then
echo "$1 is not logged on."
echo "Exit"
exit
fi
allowed=$(who -T | grep -i -m 1 $1 | awk '{print $2}')
if [ $allowed != "+" ]
then
echo "$1 does not allowing messaging."
echo "Exit"
exit
fi
if [ -z $2 ]
then
echo "No message parameter included."
echo "Exit"
exit
fi
terminal=$(who | grep -i -m 1 $1 | awk '{print $2}')
shift
while [ -n "$1" ]
do
whole_message=$whole_message' '$1
shift
done
echo $whole_message | write $logged_on $terminal
```

  
Испытаем его:  
  

```
$ ./senderscript likegeeks welcome to shell scripting
```

  

![](/images/c85623c06f86712b250620ce794d7e6e.png)

  
_Успешная отправка длинного сообщения:_  
  
Длинное сообщение успешно дошло до адресата. Теперь рассмотрим следующий пример.  
  

## Скрипт для мониторинга дискового пространства

  
Сейчас мы собираемся создать сценарий командной строки, который предназначен для поиска в заданных директориях первой десятки папок, на которые приходится больше всего дискового пространства. В этом нам поможет[команда](https://likegeeks.com/main-linux-commands-easy-guide/#du-Command)`du`, которая выводит сведения о том, сколько места на диске занимают файлы и папки. По умолчанию она выводит сведения лишь о директориях, с ключом`-a`в отчёт попадают и отдельные файлы. Её ключ`-s`позволяет вывести сведения о размерах директорий. Эта команда позволяет, например, узнать объём дискового пространства, который занимают данные некоего пользователя. Вот как выглядит вызов этой команды:  
  

```
$ du -s /var/log/
```

  
Для наших целей лучше подойдёт ключ`-S`(заглавная S), так как он позволяет получить сведения как по корневой папке, так и по вложенным в неё директориям:  
  

```
$ du -S /var/log/
```

  

![](/images/42bb5e8caec726f7d312cf1f9df25a49.png)

  
_Вызов команды du с ключами -s и -S_  
  
Нам нужно найти директории, на которые приходится больше всего дискового пространства, поэтому список, который выдаёт`du`, надо отсортировать, воспользовавшись командой`sort`:  
  

```
$ du -S /var/log/ | sort -rn
```

  

![](/images/cffef29a8ee74eb8992799d26d56fa16.png)

  
_Отсортированный список объектов_  
  
Ключ`-n`указывает команде на то, что нужна числовая сортировка, ключ`-r —`на обратный порядок сортировки (самое большое число окажется в начале списка). Полученные данные вполне подходят для наших целей.  
  
Для того, чтобы ограничить полученный список первыми десятью записями, воспользуемся[потоковым редактором](https://habrahabr.ru/company/ruvds/blog/327530/)`sed`, который позволит удалить из полученного списка все строки, начиная с одиннадцатой. Следующий шаг — добавить к каждой полученной строке её номер. Тут также поможет`sed`, а именно — его команда`N`:  
  

```
sed '{11,$D; =}' |
sed 'N; s/\n/ /' |
```

  
Приведём полученные данные в порядок, воспользовавшись`awk`. Передадим`awk`то, что получилось после обработки данных с помощью`sed`, применив, как и в других случаях, конвейер, и выведем полученные данные с помощью команды`printf`:  
  

```
awk '{printf $1 ":" "\t" $2 "\t" $3 "\n"}'
```

  
В начале строки выводится её номер, потом идёт двоеточие и знак табуляции, далее — объём дискового пространства, следом — ещё один знак табуляции и имя папки.  
  
Соберём вместе всё то, о чём мы говорили:  
  

```
$ du -S /var/log/ |
sort -rn |
sed '{11,$D; =}' |
sed 'N; s/\n/ /' |
awk '{printf $1 ":" "\t" $2 "\t" $3 "\n"}'
```

  

![](/images/2857bc4fb85059664b25f99ee26ae472.png)

  
_Вывод сведений о дисковом пространстве_  
  
Для того, чтобы повысить эффективность работы скрипта, код которого вы совсем скоро увидите, реализуем возможность получения данных сразу по нескольким директориям. Для этого создадим переменную`MY_DIRECTORIES`и внесём в неё список интересующих нас директорий:  
  

```bash
MY_DIRECTORIES="/home /var/log"
```

  
Переберём список с помощью цикла`for`и вызовем вышеописанную последовательность команд для каждого элемента списка. Вот что получилось в результате:  
  

```bash
#!/bin/bash
MY_DIRECTORIES="/home /var/log"
echo "Top Ten Disk Space Usage"
for DIR in $MY_DIRECTORIES
do
echo "The $DIR Directory:"
du -S $DIR 2>/dev/null |
sort -rn |
sed '{11,$D; =}' |
sed 'N; s/\n/ /' |
awk '{printf $1 ":" "\t" $2 "\t" $3 "\n"}'
done
exit
```

  

![](/images/c1868fd4a7092a83026dfee3032b1a80.png)

  
_Получение сведений о нескольких директориях_  
  
Как видите, скрипт выводит, в виде удобного списка, сведения о директориях, список которых хранится в`MY_DIRECTORIES`.  
  
Команду`du`в этом скрипте можно вызвать с другими ключами, полученный список объектов вполне можно отфильтровать, в целом — тут открывается широкий простор для самостоятельных экспериментов. В результате, вместо работы со списком папок, можно, например, найти самые большие файлы с расширением`.log,`или реализовать более сложный алгоритм поиска самых больших (или самых маленьких) файлов и папок.

# Bash-скрипты, часть 11: expect и автоматизация интерактивных утилит

## Основы expect

  
Если expect в вашей системе не установлен, исправить это, например, в Ubuntu, можно так:  
  

```
$ apt-get install expect
```

  
В чём-то вроде CentOs установка выполняется такой командой:  
  

```
$ yum install expect
```

  
Expect предоставляет набор команд, позволяющих взаимодействовать с утилитами командной строки. Вот его основные команды:  
  

*   `spawn` — запуск процесса или программы. Например, это может быть командная оболочка,[FTP](https://likegeeks.com/ftp-server-linux/), Telnet, ssh, scp и так далее.  
      
    
*   `expect` — ожидание данных, выводимых программой. При написании скрипта можно указать, какого именно вывода он ждёт и как на него нужно реагировать.  
      
    
*   `send` — отправка ответа. Expect-скрипт с помощью этой команды может отправлять входные данные автоматизируемой программе. Она похожа на знакомую вам команду`echo`в обычных bash-скриптах.  
      
    
*   `interact` — позволяет переключиться на «ручной» режим управления программой.  
    

  

## Автоматизация bash-скрипта

  
Напишем скрипт, который взаимодействует с пользователем и автоматизируем его с помощью expect. Вот код bash-скрипта`questions`:  
  

```bash
#!/bin/bash
echo "Hello, who are you?"
read $REPLY
echo "Can I ask you some questions?"
read $REPLY
echo "What is your favorite topic?"
read $REPLY
```

  
Теперь напишем expect-скрипт, который запустит скрипт`questions`и будет отвечать на его вопросы:  
  

```
#!/usr/bin/expect -f
set timeout -1
spawn ./questions
expect "Hello, who are you?\r"
send -- "Im Adam\r"
expect "Can I ask you some questions?\r"
send -- "Sure\r"
expect "What is your favorite topic?\r"
send -- "Technology\r"
expect eof
```

  
Сохраним скрипт, дав ему имя`answerbot`.  
  
В начале скрипта находится строка идентификации, которая, в данном случае, содержит путь к expect, так как интерпретировать скрипт будет именно expect.  
Во второй строке мы отключаем тайм-аут, устанавливая переменную expect`timeout`в значение -1. Остальной код — это и есть автоматизация работы с bash-скриптом.  
  
Сначала, с помощью команды`spawn`, мы запускаем bash-скрипт. Естественно, тут может быть вызвана любая другая утилита командной строки. Далее задана последовательность вопросов, поступающих от bash-скрипта, и ответов, которые даёт на них expect. Получив вопрос от подпроцесса, expect выдаёт ему заданный ответ и ожидает следующего вопроса.  
  
В последней команде expect ожидает признака конца файла, скрипт, дойдя до этой команды, завершается.  
  
Теперь пришло время всё это опробовать. Сделаем`answerbot`исполняемым файлом:  
  

```
$ chmod +x ./answerbot
```

  
И вызовем его:  
  

```
$./answerbot
```

  

![](/images/45654e80149d0ffc4f4fa6616857ef44.png)

  
_Expect-скрипт отвечает на вопросы bash-скрипта_  
  
Как видно, expect-скрипт верно ответил на вопросы bash-скрипта. Если на данном этапе вы столкнулись с ошибкой, вызванной тем, что неправильно указано расположение expect, выяснить его адрес можно так:  
  

```
$ which expect
```

  
Обратите внимание на то, что после запуска скрипта`answerbot`всё происходит в полностью автоматическом режиме. То же самое можно проделать для любой утилиты командной строки. Тут надо отметить, что наш bash-скрипт устроен очень просто, мы точно знаем, какие именно данные он выводит, поэтому написать expect-скрипт для взаимодействия с ним несложно. Задача усложняется при работе с программами, которые написаны другими разработчиками. Однако, здесь на помощь приходит средство для автоматизированного создания expect-скриптов.  
  

## Autoexpect — автоматизированное создание expect-скриптов

  
Autoexpect позволяет запускать программы, которые надо автоматизировать, после чего записывает то, что они выводят, и то, что пользователь вводит, отвечая на их вопросы. Вызовем autoexpect, передав этой утилите имя нашего скрипта:  
  

```
$ autoexpect ./questions
```

  
В этом режиме взаимодействие с bash-скриптом ничем не отличается от обычного: мы сами вводим ответы на его вопросы.  
  

![](/images/fb81310fe0054606d27778474d80079f.png)

  
_Запуск bash-скрипта с помощью autoexpect_  
  
После завершения работы с bash-скриптом, autoexpect сообщит о том, что собранные данные записаны в файл`script.exp`. Взглянем на этот файл.  
  

![](/images/10fe731bd35562c114a5158121450126.png)

  
_Файл script.exp_  
  
В целом, за исключением некоторых деталей, перед нами такой же скрипт, который мы писали самостоятельно. Если запустить этот скрипт, результат будет тем же.  
  

![](/images/0a20d545683e4b5b5469495a642671ab.png)

  
_Запуск expect-скрипта, созданного автоматически_  
  
При записи сеансов взаимодействия с некоторыми программами, вроде FTP-клиентов, вы можете столкнуться с тем, что они используют в выводимых данных сведения о времени проведения операции, или выводят данные, отражающие процесс выполнения неких продолжительных действий. В целом, речь идёт о том, что вывод программы при каждом её запуске, правильно воспринимаемый человеком и вызывающий ввод одних и тех же ответов, будет, в тех же условиях, выглядеть по-новому для expect.  
  
Если в expect-скрипте строки, ожидаемые от такой программы, будут жёстко зафиксированы, такой скрипт не сможет нормально работать. Справиться с этим можно, либо удалив из expect-скрипта данные, которые выглядят по-новому при каждом запуске программы, либо использовав шаблоны, пользуясь которыми, expect сможет правильно понять то, что хочет от него программа.  
  
Как видите, autoexpect — это весьма полезный инструмент, но и он не лишён недостатков, исправить которые можно только вручную. Поэтому продолжим осваивать язык expect-скриптов.  
  

## Работа с переменными и параметрами командной строки

  
Для объявления переменных в expect-скриптах используется команда`set`. Например, для того, чтобы присвоить значение 5 переменной`VAR1`, используется следующая конструкция:  
  

```
set VAR1 5
```

  
Для доступа к значению переменной перед её именем надо добавить знак доллара —`$`. В нашем случае это будет выглядеть как`$VAR1`.  
  
Для того, чтобы получить доступ к аргументам командной строки, с которыми вызван expect-скрипт, можно поступить так:  
  

```
set VAR [lindex $argv 0]
```

  
Тут мы объявляем переменную`VAR`и записываем в неё указатель на первый аргумент командной строки,`$argv 0`.  
  
Для целей обновлённого expect-скрипта мы собираемся записать значение первого аргумента, представляющее собой имя пользователя, которое будет использовано в программе, в переменную`my_name`. Второй аргумент, символизирующий то, что пользователю нравится, попадёт в переменную`my_favorite`. В результате объявление переменных будет выглядеть так:  
  

```
set my_name [lindex $argv 0]
set my_favorite [lindex $argv 1]
```

  
Отредактируем скрипт`answerbot`, приведя его к такому виду:  
  

```
#!/usr/bin/expect -f
set my_name [lindex $argv 0]
set my_favorite [lindex $argv 1]
set timeout -1
spawn ./questions
expect "Hello, who are you?\r"
send -- "Im $my_name\r"
expect "Can I ask you some questions?\r"
send -- "Sure\r"
expect "What is your favorite topic?\r"
send -- "$my_favorite\r"
expect eof
```

  
Запустим его, передав в качестве первого параметра`SomeName`, в качестве второго —`Programming`:  
  

```
$ ./answerbot SomeName Programming
```

  

![](/images/850bb09e300047626407ed2b0c8ccee1.png)

  
_Expect-скрипт, использующий переменные и параметры командной строки_  
  
Как видите, всё работает так, как ожидалось. Теперь expect-скрипт отвечает на вопросы bash-скрипта, пользуясь переданными ему параметрами командной строки.  
  

## Ответы на разные вопросы, которые могут появиться в одном и том же месте

  
Если автоматизируемая программа может, в одной ситуации, выдать одну строку, а в другой, в том же самом месте — другую, в expect можно использовать блоки, заключённые в фигурные скобки и содержащие варианты реакции скрипта на разные данные, полученные от программы. Выглядит это так:  
  

```
expect {
    "something" { send -- "send this\r" }
    "*another" { send -- "send another\r" }
}
```

  
Здесь, если expect-скрипт увидит строку «something», он отправит ответ «send this». Если же это будет некая строка, оканчивающаяся на «another», он отправит ответ «send another».  
  
Напишем новый скрипт, записав его в файл`questions`, случайным образом задающий в одном и том же месте разные вопросы:  
  

```bash
#!/bin/bash
let number=$RANDOM
if [ $number -gt 25000 ]
then
echo "What is your favorite topic?"
else
echo "What is your favorite movie?"
fi
read $REPLY
```

  
Тут мы генерируем случайное число при каждом запуске скрипта, и, проанализировав его, выводим один из двух вопросов.  
  
Для автоматизации такого скрипта нам и пригодится вышеописанная конструкция:  
  

```
#!/usr/bin/expect -f
set timeout -1
spawn ./questions
expect {
    "*topic?" { send -- "Programming\r" }
    "*movie?" { send -- "Star wars\r" }
}
```

  

![](/images/cceaeb72a9cfe0513d09353f1e01c485.png)

  
_Ответы на разные вопросы, появляющиеся в одном и том же месте_  
  
Как видно, когда автоматизированный скрипт выводит строку, оканчивающуюся на «topic?», expect-скрипт передаёт ему строку «Programming». Получив в том же месте, при другом запуске программы, вопрос, оканчивающийся на «movie?», expect-скрипт отвечает: «Star wars». Это очень полезная техника.  
  

## Условный оператор

  
Expect поддерживает условный оператор`if-else`и другие управляющие конструкции. Вот пример использования условного оператора:  
  

```
#!/usr/bin/expect -f
set TOTAL 1
if { $TOTAL < 5 } {
puts "\nTOTAL is less than 5\n"
} elseif { $TOTAL > 5 } {
puts "\nTOTAL greater than 5\n"
} else {
puts "\nTOTAL is equal to 5\n"
}
expect eof
```

  

![](/images/8c69e055846d656af2cc6c11da767b73.png)

  
_Условный оператор в expect_  
  
Тут мы присваиваем переменной`TOTAL`некое число, после чего проверяем его и выводим текст, зависящий от результата проверки.  
  
Обратите внимание на конфигурацию фигурных скобок. Очередная открывающая скобка должна быть расположена на той же строке, что и предыдущие конструкции.  
  

## Цикл while

  
Циклы`while`в expect очень похожи на те, что используются в обычных bash-скриптах, но, опять же, тут применяются фигурные скобки:  
  

```
#!/usr/bin/expect -f
set COUNT 0
while { $COUNT <= 5 } {
puts "\nCOUNT is currently at $COUNT"
set COUNT [ expr $COUNT + 1 ]
}
puts ""
```

  

![](/images/19F2r17sDNowQV52cowtXGsMOl__tiRLfkzmj7MjygsMzuDL5RPeUu_Mhb2a2zYWrsfTT6ycbrAIKjtq0EPHhw58sTJqAo6HqZd5Vh8QCp15saZVlCHHZdPNoiiRxXU1w4bJXgAWpw_vIYb0BA)

  
_Цикл while в expect_  
  

## Цикл for

  
Цикл`for`в expect устроен по-особому. В начале цикла, в самостоятельных парах фигурных скобок, надо указать переменную-счётчик, условие прекращения цикла и правило модификации счётчика. Затем, опять же в фигурных скобках, идёт тело цикла:  
  

```
#!/usr/bin/expect -f
for {set COUNT 0} {$COUNT <= 5} {incr COUNT} {
puts "\nCOUNT is at $COUNT"
}
puts ""
```

  

![](/images/h3Hyo_lzUuZJnYZ9taZ1XvIY-IhWkG8eyyi8nEbELzQDP_M42RCOH2QPn1T-Qv41NMv9Zzk4O0vQUtW_SUy4Pset1Sl_wH14_YgJvYWl_ecMsl3wFzqkQIeHr_n3GU_aF6jTZqsgQhQ-wYyamw)

  
_Цикл for в expect_  
  

## Объявление и использование функций

  
Expect позволяет программисту объявлять функции, используя ключевое слово`proc`:  
  

```
proc myfunc { MY_COUNT } {
set MY_COUNT [expr $MY_COUNT + 1]
return "$MY_COUNT"
}
```

  
Вот как выглядит expect-скрипт, в котором используется объявленная в нём же функция:  
  

```
#!/usr/bin/expect -f

proc myfunc { MY_COUNT } {
set MY_COUNT [expr $MY_COUNT + 1]
return "$MY_COUNT"
}

set COUNT 0
while {$COUNT <= 5} {
puts "\nCOUNT is currently at $COUNT"
set COUNT [myfunc $COUNT]
}
puts ""
```

  

![](/images/4rvWSMdIyQR0zXItxldVlUntwL36cCK0iQ4jOKbpE_YeD123l5-DhUCZbh10y4hELKAhAuc5mfz17ZxVBzGZz0Cvg3dQnpdn8NhaollSGPua6nBHFp_6LjEXSXYl6yBu521Eg-CuHoSPDcK_fw)

  
_Функции в expect_  
  

## Команда interact

  
Случается так, что автоматизируемые с помощью expect программы требуют ввода конфиденциальных данных, вроде паролей, которые вам не хотелось бы хранить в виде обычного текста в коде скрипта. В подобной ситуации можно воспользоваться командой`interact`, которая позволит вам, автоматизировав некую часть взаимодействия с программой, самостоятельно ввести, скажем, пароль, а потом опять передать управление expect.  
  
Когда выполняется эта команда, expect-скрипт переключается на чтение ответа на вопрос программы с клавиатуры, вместо того, чтобы передавать ей ранее записанные в нём данные.  
  
Вот bash-скрипт, в общем-то, точно такой же, как мы рассматривали ранее, но теперь ожидающий ввод пароля в ответ на один из своих вопросов:  
  

```bash
#!/bin/bash
echo "Hello, who are you?"
read $REPLY
echo "What is you password?"
read $REPLY
echo "What is your favorite topic?"
read $REPLY
```

  
Напишем expect-скрипт, который, когда ему предлагают предоставить пароль, передаёт управление нам:  
  

```expect
#!/usr/bin/expect -f
set timeout -1
spawn ./questions
expect "Hello, who are you?\r"
send -- "Hi Im Adam\r"
expect "*password?\r"
interact ++ return
send "\r"
expect "*topic?\r"
send -- "Technology\r"
expect eof
```

  

![](/images/QzISHnYVurZOqWM7NCNcVW8-248AGrBMf0qwzxf2WijbRWqI8eVOKcWECEod_AXg551sIKSnHJR-U5sz-qHHOk5evCg48H4kadYk0Kngk16BQSU0vYhML7xsb0TG-8R_9yABDjzws0YMbesWAQ)

  
_Команда interact в expect-скрипте_  
  
Встретив команду `interact`, expect-скрипт остановится, предоставив нам возможность ввести пароль. После ввода пароля надо ввести «++» и expect-скрипт продолжит работу, снова получив управление.