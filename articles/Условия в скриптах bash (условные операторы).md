# Условия в скриптах bash (условные операторы)

## Вступление

В Bash имеется множество встроенных проверок и сравнений, что очень удобно во многих ситуациях. Вы, наверное, видели, если такие заявления раньше:

```bash
if [ $foo -ge 3 ]; then
```

Условие в этом примере по сути является командой. Это может звучать странно, но сравнение с квадратными скобками аналогично использованию встроенной команды `test`, например:

```bash
if test $foo -ge 3; then
```

Если $foo больше(G) или равно(E) 3, блок после «then» будет выполнен. Если вы всегда задавались вопросом, почему bash использует `-ge` или `-eq` вместо >= или ==, это потому, что этот тип условия исходит из команды, где `-ge` и `-eq` - параметры.
И это то, что по сути, проверяет состояние завершения команды. Я объясню это более подробно далее в руководстве.
Также есть встроенные проверки, которые более специфичны для оболочек.

```bash
if [ -f regularfile ]; then
```

Вышеуказанное условие выполняется, если файл «regularfile» существует _и_
это обычный файл. Обычный файл означает, что это не блок или
символьное устройство или каталог. Таким образом, вы можете быть уверены, что
Файл существует, прежде чем что-то делать с ним. Вы даже можете проверить, если
файл читабелен!

```bash
if [ -r readablefile]; then
```

Приведенное выше условие выполняется, если файл «readablefile» существует и доступен для чтения. Легко, не правда ли?

## Синтаксис оператора if (краткое объяснение)

Основной синтаксис оператора _if … then_ выглядит следующим образом:

```bash
if <condition>; then
<commands>
fi
```

Условие, в зависимости от его типа, окружено определенным
скобки, например. \[\]. Вы можете прочитать о различных типах дальше
в учебнике. Вы можете добавить команды, которые будут выполняться, когда условие ложно, с помощью ключевого слова _else_ и использовать ключевое слово _elif_ (elseif) для выполнения команд с другим условием, если основное условие ложно. Ключевое слово _else_ всегда стоит последним. Пример:

```bash
if [ -r somefile ]; then
        content=$(cat somefile)
elif [ -f somefile ]; then
        echo "The file 'somefile' exists but is not readable to the script."
else
        echo "The file 'somefile' does not exist."
fi
```

Краткое объяснение примера: сначала мы проверяем, является ли файл somefile читаемым («if \[-r somefile \]»). Если так, мы читаем это в переменную. Если нет, мы проверяем, существует ли он на самом деле («elif \[-f somefile \]»). Если это правда, мы сообщаем, что он существует, но не читается (если бы это было так, мы бы прочитали содержимое). Если файл не существует, мы также сообщаем об этом. Условие в _elif_ выполняется только в том случае, если условие в _if_ было ложным. Команды, принадлежащие _else_, выполняются, только если оба условия ложны.

## Основные правила условий

Когда вы начинаете писать и использовать свои собственные условия, вы должны знать некоторые правила, чтобы избежать ошибок, которые трудно отследить. Вот три важных:

1.  **Всегда оставляйте пробелы между скобками и фактической проверкой/сравнением**. Следующие не будут работать:
    
    ```bash
    if [$foo -ge 3]; then
    ```
    
    Баш будет жаловаться на “отсутствуoщий '\]'”.
    
2.  **Всегда заканчивайте строку перед введением нового ключевого слова, такого как «then»**. Слова _if_, _then_, _else_, _elif_ и _fi_ являются ключевыми словами оболочки, что означает, что они не могут использовать одну и ту же строку. Поместите «;» между предыдущим оператором и ключевым словом или поместите ключевое слово в начале новой строки. Bash будет выдавать ошибки, такие как «ошибка синтаксиса, рядом с неожиданным токеном «fi», если вы этого не сделаете.
3.  _Это хорошая привычка заключать в кавычки строковые переменные, если вы используете их в условиях_, потому что в противном случае они могут создать проблемы, если они содержат пробелы и/или символы новой строки. Цитируя я имею в виду:
    
    ```bash
    if [ "$stringvar" == "tux" ]; then
    ```
    
    Есть несколько случаев, в которых вы не должны экранировать ковычками, но они редки. Вы увидите одну из них далее в руководстве.
    

Кроме того, есть две вещи, которые может быть полезно знать:

1.  _Вы можете инвертировать условие_, поставив перед ним «!». Пример:
    
    ```bash
    if [ ! -f regularfile ]; then
    ```
    
    Обязательно поместите "!" В скобки!
    
2.  _Вы можете комбинировать условия_ с помощью определенных операторов. Для синтаксиса с одной скобкой, который мы использовали до сих пор, вы можете использовать «-a» для _and_ и «-o» для _or_. Пример:
    
    ```bash
    if [ $foo -ge 3 -a $foo -lt 10 ]; then
    ```
    
    Приведенное выше условие вернет true, если $foo содержит целое число, большее или равное 3 и меньшее (**L**ess **T**han) 10. Подробнее об этих выражениях объединения можно прочитать в соответствующих синтаксисах условий.
    

И еще одна базовая вещь: не забывайте, что условия могут также использоваться в других операторах, таких как _while_ и _until_. Объяснение этого не входит в этот урок, но вы можете прочитать о них в [Руководстве по Bash для начинающих](http://www.tldp.org/LDP/Bash-Beginners-Guide/html/sect_09_02.html.).

Во всяком случае, я пока показал вам только условия в одинарных скобках. Однако есть и другие синтаксисы, о которых вы узнаете в следующем разделе.

## Различные синтаксисы условий

Bash имеет различные синтаксисы для условий. Я перечислю три из них:

### 1. Синтаксис с одной скобкой

Это синтаксис условия, который вы уже видели в предыдущих параграфах; это самый старый поддерживаемый синтаксис. Он поддерживает три типа условий:

*   **Файловые условия**
    *   Позволяет различные виды проверок. Пример:
        
        ```bash
        if [ -L symboliclink ]; then
        ```
        
        Приведенное выше условие верно, если файл символическая ссылка существует и является символической ссылкой. Дополнительные условия для файлов см. в [таблице](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#file-based-conditions) ниже.
        
*   **Строковые условия**
    *   Позволяет проверять строку и сравнивать строки. Пример первый:
        
        ```bash
        if [ -z "$emptystring" ]; then
        ```
        
        Вышеуказанное условие истинно, если $emptystring является пустой строкой или неинициализированной переменной. Пример два:
        
        ```bash
        if [ "$stringvar1" == "cheese" ]; then
        ```
        
        Приведенное выше условие истинно, если $stringvar1 содержит только строку «cheese». Дополнительные условия на основе строк см. в [таблице](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#string-based-conditions) ниже.
        
*   **Арифметические (числовые) условия**
    *   Позволяет сравнивать целые числа. Пример:
        
        ```bash
        if [ $num -lt 1 ]; then
        ```
        
        Приведенное выше условие возвращает true, если $num меньше 1. Более подробные арифметические условия см. в [таблице](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#arithmetic-conditions) ниже.
        

### 2\. Double-bracket syntax

You may have encountered conditions enclosed in double square brackets already, which look like this:

```
if [[ "$stringvar" == *string* ]]; then
```

The double-bracket syntax serves as an enhanced version of the single-bracket syntax; it mainly has the same features, but also some important differences with it. I will list them here:

*   _The first difference_can be seen in the above example; when comparing strings, the double-bracket syntax features shell globbing. This means that an asterisk (“\*”) will expand to literally anything, just as you probably know from normal command-line usage. Therefore, if $stringvar contains the phrase “string” anywhere, the condition will return true. Other forms of shell globbing are allowed, too. If you’d like to match both “String” and “string”, you could use the following syntax:
    
    ```
    if [[ "$stringvar" == *[sS]tring* ]]; then
    ```
    
    Note that only general shell globbing is allowed. Bash-specific things like {1..4} or {foo,bar} will not work. Also, note that the**globbing will not work if you quote the right string**. In this case, you should leave it unquoted.
    
*   _The second difference_is that word splitting is prevented. Therefore, you could omit placing quotes around string variables and use a condition like the following without problems:
    
    ```
    if [[ $stringvarwithspaces != foo ]]; then
    ```
    
    Nevertheless, the quoting string variables remains a good habit, so I recommend just to keep doing it.
    
*   _The third difference_consists of not expanding filenames. I will illustrate this difference using two examples, starting with the old single-bracket situation:
    
    ```
    if [ -a *.sh ]; then
    ```
    
    The above condition will return true if there is one single file in the working directory that has a .sh extension. If there are none, it will return false. If there are several .sh files, bash will throw an error and stop executing the script. This is because \*.sh is expanded to the files in the working directory. Using double brackets prevents this:
    
    ```
    if [[ -a *.sh ]]; then
    ```
    
    The above condition will return true only if there is a file in the working directory called “\*.sh”, no matter what other .sh files exist. The asterisk is taken literally because the double-bracket syntax does not expand filenames.
    
*   _The fourth difference_is the addition of more generally known combining expressions, or, more specific, the operators “&&” and “||”. Example:
    
    ```
    if [[ $num -eq 3 && "$stringvar" == foo ]]; then
    ```
    
    The above condition returns true if $num is equal to 3 and $stringvar is equal to “foo”. The -a and -o known from the single-bracket syntax is supported, too.
    
    Note that the_and_operator has precedence over the_or_operator, meaning that “&&” or “-a” will be evaluated before “||” or “-o”.
    
*   _The fifth difference_is that the double-bracket syntax allows regex pattern matching using the “=~” operator. See[the table](https://linuxacademy.com/blog/linux/conditions-in-bash-scripting-if-statements/#string-based-conditions)for more information.

### 3\. Double-parenthesis syntax

There also is another syntax for arithmetic (number-based) conditions, most likely adopted from the Korn shell:

```
if (( $num <= 5 )); then
```

The above condition is true if $num is less than or equal to 5. This syntax may seem more familiar to programmers. It features all the ‘normal’ operators, like “==”, “<” and “>=”. It supports the “&&” and “||” combining expressions (but not the -a and -o ones!). It is equivalent to the built-in let command.

## Table of conditions

The following table list the condition possibilities for both the single- and the double-bracket syntax. Save a single exception, the examples are given in single-bracket syntax, but are always compatible with double brackets.

<table style="box-sizing: inherit; border-spacing: 0px; border-collapse: collapse; background-color: rgb(255, 255, 255); margin: 0px 0px 1.5em; width: 740px; color: rgb(51, 51, 51); font-family: omnes-pro, Omnes, Helvetica, Arial, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><tbody style="box-sizing: inherit;"><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="file-based-conditions" name="file-based-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>&nbsp;1. File-based conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -a existingfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘existingfile’ exists.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -a tmp.tmp ]; then<br style="box-sizing: inherit;">rm -f tmp.tmp #<span>&nbsp;</span><em style="box-sizing: inherit; font-style: italic;">Make sure we’re not bothered by an old temporary file<br style="box-sizing: inherit;"></em>fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -b blockspecialfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘blockspecialfile’ exists and is block special.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Block special files are special kernel files found in /dev, mainly used for ATA devices like hard disks, cd-roms and floppy disks.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -b /dev/fd0 ]; then<br style="box-sizing: inherit;">dd if=floppy.img of=/dev/fd0 #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Write an image to a floppy</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -c characterspecialfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘characterspecialfile’ exists and is character special.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Character special files are special kernel files found in /dev, used for all kinds of purposes (audio hardware, tty’s, but also /dev/null).<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -c /dev/dsp ]; then<br style="box-sizing: inherit;">cat raw.wav &gt; /dev/dsp #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>This actually works for certain raw wav files</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -d directory ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘directory’ exists and is a directory.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">In UNIX-style, directories are a special kind of file.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -d ~/.kde ]; then<br style="box-sizing: inherit;">echo “You seem to be a kde user.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -e existingfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘existingfile’ exists.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">(same as -a, see that entry for an example)</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -f regularfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘regularfile’ exists and is a regular file.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">A regular file is neither a block or character special file nor a directory.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -f ~/.bashrc ]; then<br style="box-sizing: inherit;">source ~/.bashrc<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -g sgidfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘sgidfile’ exists and is set-group-ID.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">When the SGID-bit is set on a directory, all files created in that directory will inherit the group of the directory.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -g . ]; then<br style="box-sizing: inherit;">echo “Created files are inheriting the group ‘$(ls -ld . | awk ‘{ print $4 }’)’ from the working directory.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -G fileownedbyeffectivegroup ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘fileownedbyeffectivegroup’ exists and is owned by the effective group ID.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">The effective group id is the primary group id of the executing user.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ ! -G file ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>An exclamation mark inverts the outcome of the condition following it</em><br style="box-sizing: inherit;">chgrp $(id -g) file #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Change the group if it’s not the effective one</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -h symboliclink ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘symboliclink’ exists and is a symbolic link.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -h $pathtofile ]; then<br style="box-sizing: inherit;">pathtofile=$(readlink -e $pathtofile) #<em style="box-sizing: inherit; font-style: italic;">Make sure $pathtofile contains the actual file and not a symlink to it</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -k stickyfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘stickyfile’ exists and has its sticky bit set.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">The sticky bit has got<span>&nbsp;</span><a title="Read about the sticky bit on Wikipedia" href="http://en.wikipedia.org/wiki/Sticky_bit" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">quite a history</a>, but is now used to prevent world-writable directories from having their contents deletable by anyone.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ ! -k /tmp ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>An exclamation mark inverts the outcome of the condition following it</em><br style="box-sizing: inherit;">echo “Warning! Anyone can delete and/or rename your files in /tmp!”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -L symboliclink ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘symboliclink’ exists and is a symbolic link.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">(same as -h, see that entry for an example)</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -N modifiedsincelastread ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘modifiedsincelastread’ exists and was modified after the last read.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -N /etc/crontab ]; then<br style="box-sizing: inherit;">killall -HUP crond #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>SIGHUP makes crond reread all crontabs<br style="box-sizing: inherit;"></em>fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -O fileownedbyeffectiveuser ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘fileownedbyeffectiveuser’ exists and is owned by the user executing the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -O file ]; then<br style="box-sizing: inherit;">chmod 600 file #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Makes the file private, which is a bad idea if you don’t own it</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -p namedpipe ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘namedpipe’ exists and is a named pipe.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">A named pipe is a file in /dev/fd/ that can be read just once. See<span>&nbsp;</span><a title="See a way of using a named pipe in my bash tutorial" href="http://www.linuxtutorialblog.com/post/tutorial-the-best-tips-tricks-for-bash#using-several-ways-of-substitution" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">my bash tutorial</a><span>&nbsp;</span>for a case in which it’s used.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -p $file ]; then<br style="box-sizing: inherit;">cp $file tmp.tmp #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Make sure we’ll be able to read</em><br style="box-sizing: inherit;">file=”tmp.tmp”&nbsp;&nbsp;&nbsp; #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>the file as many times as we like</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -r readablefile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘readablefile’ exists and is readable to the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [-r file ]; then<br style="box-sizing: inherit;">content=$(cat file) #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Set $content to the content of the file<br style="box-sizing: inherit;"></em>fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -s nonemptyfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘nonemptyfile’ exists and has a size of more than 0 bytes.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -s logfile ]; then<br style="box-sizing: inherit;">gzip logfile&nbsp;&nbsp;&nbsp; #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Backup the old logfile</em><br style="box-sizing: inherit;">touch logfile #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>before creating a fresh one.</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -S socket ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘socket’ exists and is a socket.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">A socket file is used for inter-process communication, and features an interface similar to a network connection.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -S /var/lib/mysql/mysql.sock ]; then<br style="box-sizing: inherit;">mysql –socket=/var/lib/mysql/mysql.sock #<em style="box-sizing: inherit; font-style: italic;">See<span>&nbsp;</span><a title="MySQL socket in non-default place" href="http://www.tech-recipes.com/mysql_tips762.html" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">this MySQL tip</a><br style="box-sizing: inherit;"></em>fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -t openterminal ]</td><td style="box-sizing: inherit; padding: 0.4em;">file descriptor ‘openterminal’ exists and refers to an open terminal.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Virtually everything is done using files on Linux/UNIX, and the terminal is no exception.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -t /dev/pts/3 ]; then<br style="box-sizing: inherit;">echo -e “nHello there. Message from terminal $(tty) to you.” &gt; /dev/pts/3 #<em style="box-sizing: inherit; font-style: italic;">Anyone using that terminal will actually see this message!</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -u suidfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘suidfile’ exists and is set-user-ID.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Setting the suid-bit on a file causes execution of that file to be done with the credentials of the owner of the file, not of the executing user.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -u executable ]; then<br style="box-sizing: inherit;">echo “Running program executable as user $(ls -l executable | awk ‘{ print $3 }’).”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -w writeablefile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘writeablefile’ exists and is writeable to the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ -w /dev/hda ]; then<br style="box-sizing: inherit;">grub-install /dev/hda<br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -x executablefile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘executablefile’ exists and is executable for the script.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Note that the execute permission on a directory means that it’s searchable (you can see which files it contains).<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -x /root ]; then<br style="box-sizing: inherit;">echo “You can view the contents of the /root directory.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ newerfile -nt olderfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘newerfile’ was changed more recently than ‘olderfile’, or if ‘newerfile’ exists and ‘olderfile’ doesn’t.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ story.txt1 -nt story.txt ]; then<br style="box-sizing: inherit;">echo “story.txt1 is newer than story.txt; I suggest continuing with the former.”<br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ olderfile -ot newerfile ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘olderfile’ was changed longer ago than ‘newerfile’, or if ‘newerfile’ exists and ‘olderfile’ doesn’t.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ /mnt/remote/remotefile -ot localfile ]; then<br style="box-sizing: inherit;">cp -f localfile /mnt/remote/remotefile #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Make sure the remote location has the newest version of the file, too</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ same -ef file ]</td><td style="box-sizing: inherit; padding: 0.4em;">file ‘same’ and file ‘file’ refer to the same device/inode number.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ /dev/cdrom -ef /dev/dvd ]; then<br style="box-sizing: inherit;">echo “Your primary cd drive appears to read dvd’s, too.”<br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="string-based-conditions" name="string-based-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>&nbsp;2. String-based conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 == STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 is equal to STRING2.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ “$1” == “moo” ]; then<br style="box-sizing: inherit;">echo $cow #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Ever tried executing ‘apt-get moo’?<br style="box-sizing: inherit;"></em>fiNote: you can also use a single “=” instead of a double one.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 != STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 is not equal to STRING2.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">if [ “$userinput” != “$password” ]; then<br style="box-sizing: inherit;">echo “Access denied! Wrong password!”<br style="box-sizing: inherit;">exit 1 #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Stops script execution right here</em><br style="box-sizing: inherit;">fi</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 &gt; STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 sorts after STRING2 in the current locale (lexographically).</td><td rowspan="2" valign="top" style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">The backslash before the angle bracket is there because the bracket needs to be escaped to be interpreted correctly. As an example we have a basic<span>&nbsp;</span><a title="What is a bubble sort? See wikipedia!" href="http://en.wikipedia.org/wiki/Sorting_algorithm#Bubble_sort" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;">bubble sort</a>:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"><em style="box-sizing: inherit; font-style: italic;">(Don’t feel ashamed if you don’t understand this, it is a more complex example)</em></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">array=( linux tutorial blog )<br style="box-sizing: inherit;">swaps=1<br style="box-sizing: inherit;">while (( swaps &gt; 0 )); do</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">swaps=0<br style="box-sizing: inherit;">for (( i=0; i &lt; (( ${#array[@]} – 1 )) ; i++ )); do<br style="box-sizing: inherit;">if [ “${array[$i]}” &gt; “${array[$(( i + 1 ))]}” ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Here is the sorting condition</em><br style="box-sizing: inherit;">tempstring=${array[$i]}<br style="box-sizing: inherit;">array[$i]=${array[$(( i + 1 ))]}<br style="box-sizing: inherit;">array[$(( i + 1 ))]=$tempstring<br style="box-sizing: inherit;">(( swaps=swaps + 1 ))<br style="box-sizing: inherit;">fi<br style="box-sizing: inherit;">done<br style="box-sizing: inherit;">done<br style="box-sizing: inherit;">echo ${array[@]} #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>Returns “blog linux tutorial”</em></p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ STRING1 &lt; STRING2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">STRING1 sorts before STRING2 in the current locale (lexographically).</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -n NONEMPTYSTRING ]</td><td style="box-sizing: inherit; padding: 0.4em;">NONEMPTYSTRING has a length of more than zero.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">This condition only accepts valid strings, so be sure to quote anything you give to it.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -n “$userinput” ]; then<br style="box-sizing: inherit;">userinput=parse($userinput) #<span>&nbsp;</span><em style="box-sizing: inherit; font-style: italic;">Only parse if the user actually gave some input.</em><br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">Note that you can also omit the “-n”, as brackets with just a string in it behave the same.</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -z EMPTYSTRING ]</td><td style="box-sizing: inherit; padding: 0.4em;">EMPTYSTRING is an empty string.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">This condition also accepts non-string input, like an uninitialized variable:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -z $uninitializedvar ]; then<br style="box-sizing: inherit;">uninitializedvar=”initialized” #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>-z returns true on an uninitialized variable, so we initialize it here.</em><br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;"><em style="box-sizing: inherit; font-style: italic;">Double-bracket syntax only:<br style="box-sizing: inherit;"></em>[[ STRING1 =~ REGEXPATTERN ]]</td><td style="box-sizing: inherit; padding: 0.4em;">STRING1 matches REGEXPATTERN.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">If you are familiar with Regular Expressions, you can use this conditions to perform a regex match.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [[ “$email” =~ “b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Za-z]{2,4}b” ]]; then<br style="box-sizing: inherit;">echo “$email contains a valid e-mail address.”<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="arithmetic-conditions" name="arithmetic-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>&nbsp;3. Arithmetic (number-based) conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -eq NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">EQ</strong>ual to NUM2.</td><td rowspan="6" valign="top" style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">These conditions only accept integer numbers. Strings will be converted to integer numbers, if possible. Some random examples:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ $? -eq 0 ]; then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>$? returns the exit status of the previous command</em><br style="box-sizing: inherit;">echo “Previous command ran succesfully.”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ $(ps -p $pid -o ni=) -ne $(nice) ]; then<br style="box-sizing: inherit;">echo “Process $pid is running with a non-default nice value”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ $num -lt 0 ]; then<br style="box-sizing: inherit;">echo “Negative numbers not allowed; exiting…”<br style="box-sizing: inherit;">exit 1<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -ne NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">N</strong>ot<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">E</strong>qual to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -gt NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">G</strong>reater<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">T</strong>han NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -ge NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">G</strong>reater than or<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">E</strong>qual to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -lt NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">L</strong>ess<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">T</strong>han NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ NUM1 -le NUM2 ]</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">L</strong>ess than or<span>&nbsp;</span><strong style="box-sizing: inherit; font-weight: 700;">E</strong>qual to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="miscellaneous-conditions" name="miscellaneous-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>4. Miscellaneous conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">[ -o shelloption ]</td><td style="box-sizing: inherit; padding: 0.4em;">shell option ‘shelloption’ is enabled.</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">Shell options modify the behaviour of bash, except a few unmodifiable ones that indicate the shell status.<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ ! -o checkwinsize ] #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>An exclamation mark inverts the outcome of the condition following it</em><br style="box-sizing: inherit;">echo “Shell option checkwinsize is disabled; enabling it so you can resize you terminal window without problems.”<br style="box-sizing: inherit;">shopt -s checkwinsize #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>This shell option is modifiable</em><br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if [ -o login_shell ]; then<br style="box-sizing: inherit;">echo “This a a login shell.” #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>This shell option is not modifiable<br style="box-sizing: inherit;"></em><br style="box-sizing: inherit;">fi</p></td></tr></tbody></table>

With the double-parenthesis syntax, you can use the following conditions:

<table style="box-sizing: inherit; border-spacing: 0px; border-collapse: collapse; background-color: rgb(255, 255, 255); margin: 0px 0px 1.5em; width: 740px; color: rgb(51, 51, 51); font-family: omnes-pro, Omnes, Helvetica, Arial, sans-serif; font-size: 18px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"><tbody style="box-sizing: inherit;"><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td class="colspan" colspan="3" style="box-sizing: inherit; padding: 0.4em 0px;"><h3 style="box-sizing: inherit; font-family: inherit; font-weight: 400; line-height: 1.2em; color: rgb(24, 35, 41); margin: 0px 0px 0.75em; font-size: 24px; clear: both; padding: 0px;"><a title="double-parenthesis-syntax-conditions" name="double-parenthesis-syntax-conditions" style="box-sizing: inherit; background-color: transparent; color: rgb(114, 161, 190); text-decoration: none; transition: opacity 0.2s ease 0s;"></a>5. Double-parenthesis syntax conditions:</h3></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><th style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px; text-align: left;">Condition</th><th style="box-sizing: inherit; padding: 0.4em; text-align: left;">True if</th><th style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em; text-align: left;">Example/explanation</th></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 == NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em;">NUM1 is equal to NUM2.</td><td rowspan="6" valign="top" style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">These conditions only accept integer numbers. Strings will be converted to integer numbers, if possible. Some random examples:<p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;"></p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if (( $? == 0 )); then #<em style="box-sizing: inherit; font-style: italic;"><span>&nbsp;</span>$? returns the exit status of the previous command</em><br style="box-sizing: inherit;">echo “Previous command ran succesfully.”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if (( $(ps -p $pid -o ni=) != $(nice) )); then<br style="box-sizing: inherit;">echo “Process $pid is running with a non-default nice value”<br style="box-sizing: inherit;">fi</p><p style="box-sizing: inherit; margin: 0px 0px 1.5em; padding: 0px;">if (( $num &lt; 0 )); then<br style="box-sizing: inherit;">echo “Negative numbers not allowed; exiting…”<br style="box-sizing: inherit;">exit 1<br style="box-sizing: inherit;">fi</p></td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 != NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is not equal to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &gt; NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is greater than NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &gt;= NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is greater than or equal to NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &lt; NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is less than NUM2.</td></tr><tr style="box-sizing: inherit; border-bottom: 1px solid rgb(238, 238, 238);"><td style="box-sizing: inherit; padding: 0.4em 0.4em 0.4em 0px;">(( NUM1 &lt;= NUM2 ))</td><td style="box-sizing: inherit; padding: 0.4em 0px 0.4em 0.4em;">NUM1 is less than or&nbsp;equal to NUM2.</td></tr></tbody></table>

After this dry information load, here’s a bit of explanation for those who want to know more…

## Diving a little deeper

I said I’d tell more about the fact that_if_essentially checks the exit status of commands. And so I will. The basic rule of bash when it comes to conditions is_0 equals true, >0 equals false_.  
That’s pretty much the opposite of many programming languages where 0 equals false and 1 (or more) equals true. The reason behind this is that shells like bash deal with programs a lot. By UNIX convention, programs use an exit status for indicating whether execution went alright or an error occurred. As a successful execution doesn’t require any explanation, it needs only one exit status. If there was a problem, however, it is useful to know what went wrong. Therefore, 0 is used for a successful execution, and 1-255 to indicate what kind of error occurred. The meaning of the numbers 1-255 differs depending on the program returning them.

Anyway,_if_executes the block after_then_when the command returns 0. Yes, conditions are commands. The phrase \[ $foo -ge 3 \] returns an exit status, and the other two syntaxes as well! Therefore, there’s a neat trick you can use to quickly test a condition:

```
[ $foo -ge 3 ] && echo true
```

In this example, “echo true” is only executed if “\[ $foo -ge 3 \]” returns 0 (true). Why is that, you might ask. It’s because bash only evaluates a condition when needed. When using the_and_combining expression, both conditions need to be true to make the combining expression return true. If the first condition returns false, it doesn’t matter what the second one returns; the result will be false. Therefore, bash doesn’t evaluate the second condition, and that’s the reason why “echo true” is not executed in the example. This is the same for the_or_operator (“||”), where the second condition is not evaluated if the first one is true.

Well, so much for diving in. If you want to know even more, I’d like to point you to the[Advanced Bash-Scripting Guide](http://www.tldp.org/LDP/abs/html/tests.html "Go to the "Tests" section of the Advanced Bash-Scripting Guide")and maybe the[Bash Reference Manual](http://www.gnu.org/software/bash/manual/bashref.html#Conditional-Constructs "Read about conditional constructs in the Bash Reference Manual"), or even this[System Administrator’s Guide to Bash Scripting](https://linuxacademy.com/linux/training/course/name/the-system-administrators-guidep-to-bash-scripting?utm_source=website&utm_medium=blog&utm_campaign=bashblo).